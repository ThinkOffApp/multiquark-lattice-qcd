<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SU(2) Run Dashboard</title>
  <style>
    :root {
      --bg: #0b1220;
      --card: #121a2b;
      --text: #e7edf7;
      --muted: #9fb0cc;
      --accent: #22c55e;
      --warn: #f59e0b;
      --bar-bg: #283349;
      --line: #33405a;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(180deg, #070c17 0%, #0b1220 100%);
      color: var(--text);
      min-height: 100vh;
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      margin: 0 0 14px;
      font-size: 24px;
      letter-spacing: 0.2px;
    }
    .controls, .card, .chart-card {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 14px;
      margin-bottom: 12px;
    }
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .grid-3 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    @media (max-width: 900px) {
      .grid-2, .grid-3 { grid-template-columns: 1fr; }
    }
    label {
      font-size: 12px;
      color: var(--muted);
      display: block;
      margin-bottom: 6px;
    }
    input {
      width: 100%;
      padding: 9px 10px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #0f1627;
      color: var(--text);
      outline: none;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    button {
      border: 1px solid var(--line);
      background: #162138;
      color: var(--text);
      padding: 9px 12px;
      border-radius: 8px;
      cursor: pointer;
    }
    button:hover { background: #1b2a47; }
    .badge {
      display: inline-block;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      background: #1d2a44;
      border: 1px solid var(--line);
      color: var(--muted);
    }
    .metric-title { font-size: 12px; color: var(--muted); margin-bottom: 5px; }
    .metric-value { font-size: 22px; font-weight: 700; }
    .bar {
      width: 100%;
      height: 14px;
      background: var(--bar-bg);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--line);
    }
    .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #1fbf73, #3ad38d);
      transition: width 0.2s linear;
    }
    .sub-fill {
      background: linear-gradient(90deg, #2ea6ff, #5fc3ff);
    }
    .warn-fill {
      background: linear-gradient(90deg, #e7a92e, #f4ca62);
    }
    .cfg-thread-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 6px;
    }
    .cfg-thread-segment {
      position: relative;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--bar-bg);
      overflow: hidden;
    }
    .cfg-thread-fill {
      height: 100%;
      width: 0%;
      transition: width 0.2s linear;
      background: var(--cfg-color);
    }
    .cfg-thread-segment.thread-a { --cfg-color: #52adff; }
    .cfg-thread-segment.thread-b { --cfg-color: #2fd08a; }
    .cfg-thread-segment.thread-c { --cfg-color: #f2c14b; }
    .cfg-thread-segment.thread-d { --cfg-color: #f87171; }
    .cfg-thread-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
      font-size: 10px;
      line-height: 1;
      font-weight: 600;
      color: #d9e7ff;
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }
    .hint { font-size: 12px; color: var(--muted); }
    canvas {
      width: 100%;
      height: 220px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: #0d1526;
      display: block;
    }
    .cursor-canvas {
      height: 170px;
    }
    .cursor-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    @media (max-width: 900px) {
      .cursor-grid {
        grid-template-columns: 1fr;
      }
    }
    .cursor-thread-card {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 7px;
      background: #0d1526;
    }
    .cursor-thread-card .row {
      margin-bottom: 4px;
    }
    .cursor-thread-meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 4px;
    }
    .cursor-thread-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }
    .cursor-thread-cfg {
      color: #cbd7ea;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    .cursor-thread-top-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      flex-wrap: wrap;
    }
    .thread-stat-chip {
      border: 1px solid rgba(117, 138, 170, 0.45);
      border-radius: 999px;
      padding: 1px 8px;
      font-size: 10px;
      color: #cbd7ea;
      background: rgba(117, 138, 170, 0.14);
      white-space: nowrap;
      line-height: 1.45;
    }
    .cursor-thread-controls {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 5px;
      flex-wrap: wrap;
    }
    .thread-ctl-btn {
      border: 1px solid rgba(117, 138, 170, 0.48);
      background: rgba(117, 138, 170, 0.16);
      color: #cbd7ea;
      border-radius: 6px;
      font-size: 10px;
      line-height: 1.25;
      padding: 3px 8px;
      cursor: pointer;
    }
    .thread-ctl-btn:hover {
      border-color: rgba(82, 173, 255, 0.85);
      color: #e7f1ff;
    }
    .thread-ctl-btn:disabled {
      opacity: 0.45;
      cursor: default;
    }
    .thread-all-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 2px 0 8px;
      flex-wrap: wrap;
    }
    .cursor-grid > .thread-all-controls {
      grid-column: 1 / -1;
    }
    .thread-all-btn {
      border: 1px solid rgba(117, 138, 170, 0.55);
      background: rgba(117, 138, 170, 0.18);
      color: #d8e5fa;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.2;
      font-weight: 700;
      padding: 6px 12px;
      cursor: pointer;
    }
    .thread-all-btn:hover {
      border-color: rgba(82, 173, 255, 0.9);
      color: #ffffff;
    }
    .thread-all-btn.danger {
      border-color: rgba(248, 113, 113, 0.65);
      background: rgba(248, 113, 113, 0.18);
    }
    .thread-all-btn:disabled {
      opacity: 0.45;
      cursor: default;
    }
    .stage-pipeline {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 4px;
      margin-bottom: 5px;
    }
    .stage-chip {
      position: relative;
      overflow: hidden;
      border-radius: 6px;
      border: 1px solid rgba(117, 138, 170, 0.38);
      background: rgba(117, 138, 170, 0.10);
      color: #8fa2bf;
      font-size: 10px;
      line-height: 1.1;
      text-align: center;
      padding: 3px 2px;
      --stage-fill: 0%;
    }
    .stage-chip::before {
      content: "";
      position: absolute;
      inset: 0;
      width: var(--stage-fill);
      background: rgba(82, 173, 255, 0.20);
      z-index: 0;
      pointer-events: none;
    }
    .stage-chip > span {
      position: relative;
      z-index: 1;
    }
    .stage-chip.done {
      border-color: rgba(47, 208, 138, 0.55);
      color: #b8f6d4;
    }
    .stage-chip.done::before {
      background: rgba(47, 208, 138, 0.30);
    }
    .stage-chip.active {
      border-color: rgba(82, 173, 255, 0.60);
      color: #d9ebff;
    }
    .stage-chip.pending {
      color: #8fa2bf;
    }
    .cursor-canvas-thread {
      height: 108px;
    }
    .cursor-thread-info {
      margin-top: 4px;
      min-height: 14px;
      font-size: 11px;
      line-height: 1.2;
    }
    .thread-viz-card.cursor-mode-speed .cursor-grid {
      display: none;
    }
    .thread-viz-card:not(.cursor-mode-speed) .speed-combined-wrap {
      display: none;
    }
    .thread-viz-card.cursor-mode-speed #cursorLegendDirections {
      display: none;
    }
    .thread-viz-card:not(.cursor-mode-speed) #cursorLegendThreads {
      display: none;
    }
    .speed-canvas-all {
      height: 190px;
    }
    .cursor-pane-speed {
      display: none;
    }
    .viz-select {
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: #0f1627;
      color: var(--text);
      font-size: 12px;
    }
    .cursor-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 2px 0 8px;
      font-size: 11px;
      color: var(--muted);
    }
    .cursor-legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }
    .cursor-legend-swatch {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(203, 215, 234, 0.6);
    }
    .cursor-legend-swatch.t {
      background: #52adff;
      border-color: rgba(82, 173, 255, 0.95);
    }
    .cursor-legend-swatch.s {
      background: #f2c14b;
      border-color: rgba(242, 193, 75, 0.95);
    }
    .cursor-legend-swatch.other {
      background: #2fd08a;
      border-color: rgba(47, 208, 138, 0.95);
    }
    .cursor-legend-swatch.cfg {
      background: #ff5da2;
      border-color: rgba(255, 93, 162, 0.95);
    }
    .cursor-legend-swatch.thread-a {
      background: #52adff;
      border-color: rgba(82, 173, 255, 0.95);
    }
    .cursor-legend-swatch.thread-b {
      background: #2fd08a;
      border-color: rgba(47, 208, 138, 0.95);
    }
    .cursor-legend-swatch.thread-c {
      background: #f2c14b;
      border-color: rgba(242, 193, 75, 0.95);
    }
    .cursor-legend-swatch.thread-d {
      background: #f87171;
      border-color: rgba(248, 113, 113, 0.95);
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px;
    }
    .param-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px 12px;
      font-size: 13px;
    }
    .param-k { color: var(--muted); }
    .param-v { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .chat-log {
      height: 240px;
      overflow: auto;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: #0d1526;
    }
    .chat-row {
      margin-bottom: 8px;
      line-height: 1.35;
      font-size: 13px;
    }
    .chat-user { color: #9fd4ff; }
    .chat-assistant { color: #b9f2c8; }
    .chat-system { color: #9fb0cc; }
    .chat-input-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      margin-top: 8px;
    }
    .mono-list {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.45;
      margin-top: 8px;
      white-space: pre-wrap;
    }
    .table-wrap {
      overflow-x: auto;
    }
    .status-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .status-table th,
    .status-table td {
      text-align: left;
      padding: 8px 6px;
      border-bottom: 1px solid var(--line);
      white-space: nowrap;
    }
    .status-table th {
      color: var(--muted);
      font-weight: 600;
    }
    .fit-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 8px;
    }
    .fit-table th,
    .fit-table td {
      text-align: left;
      padding: 7px 6px;
      border-bottom: 1px solid var(--line);
      vertical-align: top;
    }
    .fit-table th {
      color: var(--muted);
      font-weight: 600;
      white-space: nowrap;
    }
    .fit-table td.fit-num {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      color: #cfe0f7;
      white-space: nowrap;
    }
    .fit-table td.fit-ref {
      color: var(--muted);
    }
    .target-ref {
      margin-left: 2px;
      font-size: 10px;
      vertical-align: super;
      line-height: 0;
    }
    .target-ref a {
      color: #9fd0ff;
      text-decoration: none;
    }
    .target-ref a:hover {
      text-decoration: underline;
    }
    .ref-list {
      margin: 8px 0 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.45;
    }
    .ref-list li {
      margin: 2px 0;
    }
    .ref-list a {
      color: #9fd0ff;
      text-decoration: none;
    }
    .ref-list a:hover {
      text-decoration: underline;
    }
    .signal-note {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      min-height: 18px;
    }
    .signal-note .signal-text {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }
    .agreement-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid transparent;
      font-size: 11px;
      font-weight: 600;
      line-height: 1.2;
      white-space: nowrap;
    }
    .agreement-green {
      color: #b8f6d4;
      background: rgba(47, 208, 138, 0.16);
      border-color: rgba(47, 208, 138, 0.42);
    }
    .agreement-yellow {
      color: #ffe2a8;
      background: rgba(245, 158, 11, 0.16);
      border-color: rgba(245, 158, 11, 0.42);
    }
    .agreement-red {
      color: #ffc6c6;
      background: rgba(248, 113, 113, 0.16);
      border-color: rgba(248, 113, 113, 0.42);
    }
    .agreement-na {
      color: var(--muted);
      background: rgba(117, 138, 170, 0.16);
      border-color: rgba(117, 138, 170, 0.42);
    }
    .phase-pill {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid transparent;
      font-weight: 600;
      line-height: 1.2;
    }
    .phase-therm {
      color: #82c7ff;
      background: rgba(82, 173, 255, 0.16);
      border-color: rgba(82, 173, 255, 0.42);
    }
    .phase-meas {
      color: #9fe9b8;
      background: rgba(47, 208, 138, 0.16);
      border-color: rgba(47, 208, 138, 0.42);
    }
    .phase-init {
      color: #ffd38a;
      background: rgba(245, 158, 11, 0.16);
      border-color: rgba(245, 158, 11, 0.42);
    }
    .phase-done {
      color: #b8f6d4;
      background: rgba(34, 197, 94, 0.16);
      border-color: rgba(34, 197, 94, 0.44);
    }
    .phase-stop {
      color: #ffc6c6;
      background: rgba(248, 113, 113, 0.16);
      border-color: rgba(248, 113, 113, 0.42);
    }
    .phase-unknown {
      color: var(--muted);
      background: rgba(117, 138, 170, 0.16);
      border-color: rgba(117, 138, 170, 0.42);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>SU(2) Measurement Dashboard</h1>

    <div class="controls">
      <div class="grid-3">
        <div>
          <label>Progress JSON path</label>
          <input id="progressPath" value="/results/su2_signal_scan/progress_petrus-su2-signal.json">
        </div>
        <div>
          <label>Live JSON path</label>
          <input id="livePath" value="/results/su2_signal_scan/live_petrus-su2-signal.json">
        </div>
        <div>
          <label>Auth token (optional)</label>
          <input id="authToken" placeholder="shared token if auth is enabled">
        </div>
      </div>
      <div style="margin-top: 8px;">
        <label>API base URL (stream/chat/data, optional)</label>
        <input id="apiBase" placeholder="http://127.0.0.1:8001">
      </div>
      <div style="margin-top: 8px;">
        <label>Lattice spacing a (fm, optional)</label>
        <input id="aFmInput" value="0.119" placeholder="override if needed">
        <div class="hint" style="margin-top: 4px;">Default for this run: a = 0.119 fm (override if needed)</div>
      </div>
      <div class="grid-3" style="margin-top: 8px;">
        <div>
          <label>Flux Display</label>
          <select id="fluxDisplayMode" style="width:100%; padding:9px 10px; border-radius:8px; border:1px solid var(--line); background:#0f1627; color:var(--text);">
            <option value="stored" selected>Stored</option>
            <option value="raw">Raw</option>
            <option value="tail_subtracted">Tail-subtracted</option>
          </select>
        </div>
        <div>
          <label>Flux Tail N</label>
          <input id="fluxTailN" value="2" placeholder="tail bins for subtraction">
        </div>
        <div>
          <label>Flux Mode Note</label>
          <div class="hint" id="fluxModeNote" style="padding-top: 9px;">stored profile from file</div>
        </div>
      </div>
      <div class="btn-row">
        <button id="reloadBtn">Reload Now</button>
        <button id="toggleBtn">Pause</button>
      </div>
      <div class="hint" style="margin-top: 8px;">
        <label style="display:flex; align-items:center; gap:8px; color:var(--text);">
          <input id="combineSeeds" type="checkbox">
          Combine all seed variants (a/b/c/d) for higher statistics &amp; smaller errors
        </label>
      </div>
      <div class="hint" style="margin-top: 8px;">
        <label style="display:flex; align-items:center; gap:8px; color:var(--text);">
          <input id="legacyFilter" type="checkbox">
          Use legacy positive-sample filtering for V(R) (off = use all samples, recommended)
        </label>
      </div>
      <div class="hint" id="streamStatus" style="margin-top: 8px;">stream: polling</div>
      <div class="hint" style="margin-top: 8px;">
        Stream server: <code>cd .. && python3 grid-gpt/tools/su2_dashboard_server.py --port 8001</code>
      </div>
    </div>

    <div class="grid-2">
      <div class="card">
        <div class="metric-title">Run Parameters</div>
        <div class="param-grid">
          <div class="param-k">Seed</div><div class="param-v" id="paramSeed">-</div>
          <div class="param-k">Lattice L</div><div class="param-v" id="paramL">-</div>
          <div class="param-k">Beta</div><div class="param-v" id="paramBeta">-</div>
          <div class="param-k">Therm sweeps</div><div class="param-v" id="paramTherm">-</div>
          <div class="param-k">Measurements</div><div class="param-v" id="paramMeas">-</div>
          <div class="param-k">R values</div><div class="param-v" id="paramR">-</div>
          <div class="param-k">T values</div><div class="param-v" id="paramT">-</div>
          <div class="param-k">Flux probe</div><div class="param-v" id="paramFlux">-</div>
          <div class="param-k">Sampling</div><div class="param-v" id="paramSampling">full</div>
          <div class="param-k">Compute backend</div><div class="param-v" id="paramCompute">-</div>
          <div class="param-k">a (fm)</div><div class="param-v" id="paramAFm">-</div>
          <div class="param-k">a⁻¹ (GeV)</div><div class="param-v" id="paramAinvGeV">-</div>
          <div class="param-k">Box size (fm)</div><div class="param-v" id="paramBoxFm">-</div>
        </div>
      </div>
      <div class="card">
        <div class="metric-title">Measured Observables</div>
        <div class="hint" id="measureWhat">
          Plaquette, Wilson loops W(R,T), Polyakov loops, and connected flux profile.
        </div>
        <div style="height: 8px;"></div>
        <div class="hint" id="measureError">
          Error bands: ±1 standard error of the mean (SEM).
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <div class="metric-title">Physical Comparison</div>
        <div class="hint">combined potential + flux diagnostics</div>
      </div>
      <div class="table-wrap">
        <table class="fit-table">
          <thead>
            <tr>
              <th>Domain</th>
              <th>Observable</th>
              <th>Measured (lattice)</th>
              <th>Physical / target</th>
              <th>Agreement</th>
            </tr>
          </thead>
          <tbody id="physicalCompareBody">
            <tr><td colspan="5" class="hint">Waiting for measurements...</td></tr>
          </tbody>
        </table>
      </div>
      <ol id="physicalRefList" class="ref-list"></ol>
      <div id="physicalCompareSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for physical-comparison signal summary...</span></div>
    </div>

    <div class="card">
      <div class="row">
        <div class="metric-title">Next Jobs To Run</div>
        <div class="hint">suggested larger L / beta scan</div>
      </div>
      <div id="nextJobsList" class="hint">Waiting for run metadata...</div>
    </div>

    <div class="card">
      <div class="row">
        <div class="metric-title">Admin Chat</div>
        <div class="hint" id="chatStatus">chat: ready</div>
      </div>
      <div id="chatLog" class="chat-log"></div>
      <div class="chat-input-row">
        <input id="chatInput" placeholder="Ask about status, interpretation, next runs..." />
        <button id="chatSendBtn">Send</button>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <div class="badge" id="phaseBadge">phase: unknown</div>
        <div class="hint" id="lastUpdate">Last update: -</div>
      </div>

      <div class="row"><div class="hint" id="overallLabel">Overall progress</div><div class="hint" id="overallPct">0%</div></div>
      <div class="bar"><div class="fill" id="overallFill"></div></div>

      <div style="height: 10px;"></div>
      <div class="row"><div class="hint">Thermalization progress</div><div class="hint" id="thermPct">0.0%</div></div>
      <div class="bar"><div class="fill sub-fill" id="thermFill"></div></div>

      <div style="height: 10px;"></div>
      <div class="row"><div class="hint">Production measurements</div><div class="hint" id="measPct">0 / 0</div></div>
      <div class="bar"><div class="fill warn-fill" id="measFill"></div></div>
      <div class="hint" id="measCounterDetail">N_meas = - / - (A=-, B=-, C=-, D=-)</div>

      <div style="height: 10px;"></div>
      <div class="row"><div class="hint">Current config progress (all threads)</div><div class="hint" id="cfgSubPct">-</div></div>
      <div class="cfg-thread-grid">
        <div class="cfg-thread-segment thread-a">
          <div class="cfg-thread-fill" id="cfgSubFillA"></div>
          <div class="cfg-thread-label" id="cfgSubLabelA">A cfg- 0.0%</div>
        </div>
        <div class="cfg-thread-segment thread-b">
          <div class="cfg-thread-fill" id="cfgSubFillB"></div>
          <div class="cfg-thread-label" id="cfgSubLabelB">B cfg- 0.0%</div>
        </div>
        <div class="cfg-thread-segment thread-c">
          <div class="cfg-thread-fill" id="cfgSubFillC"></div>
          <div class="cfg-thread-label" id="cfgSubLabelC">C cfg- 0.0%</div>
        </div>
        <div class="cfg-thread-segment thread-d">
          <div class="cfg-thread-fill" id="cfgSubFillD"></div>
          <div class="cfg-thread-label" id="cfgSubLabelD">D cfg- 0.0%</div>
        </div>
      </div>

      <div style="height: 10px;"></div>
      <div class="row"><div class="hint">Configs done / measured</div><div class="hint" id="cfgDoneMeasured">0 / 0</div></div>
    </div>

    <div class="card thread-viz-card" id="threadVizCard">
      <div class="row">
        <div class="metric-title">Per-Thread Monitor</div>
        <label class="hint" style="display:flex; align-items:center; gap:6px; margin:0;">
          view
          <select id="threadVizMode" class="viz-select">
            <option value="cursor" selected>Cursor</option>
            <option value="speed">Speed graph</option>
          </select>
        </label>
      </div>
      <div id="cursorLegend">
        <div class="cursor-legend" id="cursorLegendDirections">
          <span
            class="cursor-legend-item"
            title="Blue marks the active time direction (tdir) used by the current Wilson loop or flux operation."
          ><span class="cursor-legend-swatch t"></span>Blue: time dir (t)</span>
          <span
            class="cursor-legend-item"
            title="Amber marks the active spatial direction (sdir) used with the current time direction for loop/flux operators."
          ><span class="cursor-legend-swatch s"></span>Amber: space dir (s)</span>
          <span
            class="cursor-legend-item"
            title="Green markers are the remaining lattice axes (mu) not currently chosen as time or space direction."
          ><span class="cursor-legend-swatch other"></span>Green: other mu</span>
          <span
            class="cursor-legend-item"
            title="Magenta track is per-thread overall config progress from meas_cfg_substep_progress (0-100% of current config), independent of which mu row is active."
          ><span class="cursor-legend-swatch cfg"></span>Magenta track: cfg progress</span>
        </div>
        <div class="cursor-legend" id="cursorLegendThreads">
          <span
            class="cursor-legend-item"
            title="Blue line in speed mode: thread A seconds per config over elapsed wall-time since config start."
          ><span class="cursor-legend-swatch thread-a"></span>Blue: Thread A</span>
          <span
            class="cursor-legend-item"
            title="Green line in speed mode: thread B seconds per config over elapsed wall-time since config start."
          ><span class="cursor-legend-swatch thread-b"></span>Green: Thread B</span>
          <span
            class="cursor-legend-item"
            title="Amber line in speed mode: thread C seconds per config over elapsed wall-time since config start."
          ><span class="cursor-legend-swatch thread-c"></span>Amber: Thread C</span>
          <span
            class="cursor-legend-item"
            title="Red line in speed mode: thread D seconds per config over elapsed wall-time since config start."
          ><span class="cursor-legend-swatch thread-d"></span>Red: Thread D</span>
        </div>
      </div>
      <div class="cursor-grid">
        <div class="thread-all-controls">
          <label for="threadPipelineSelect" class="hint" style="margin-right: 2px;">Restart pipeline</label>
          <select id="threadPipelineSelect" class="thread-ctl-btn" style="padding-right: 22px;" title="Choose pipeline used when restarting workers.">
            <option value="auto" selected>Auto</option>
            <option value="cpu">CPU</option>
            <option value="gpu">GPU</option>
          </select>
          <button id="threadPauseAllBtn" class="thread-all-btn" title="Pause all four worker processes (SIGSTOP).">Pause All Threads</button>
          <button id="threadResumeAllBtn" class="thread-all-btn" title="Resume all paused worker processes (SIGCONT).">Resume All Threads</button>
          <button id="threadRestartAllBtn" class="thread-all-btn danger" title="Restart all workers from checkpoint.">Restart All Threads</button>
        </div>
        <div class="cursor-thread-card">
          <div class="row">
            <div class="cursor-thread-title">Thread A</div>
            <div class="cursor-thread-top-right">
              <div class="thread-stat-chip" id="cursorBackendA">backend -</div>
              <div class="thread-stat-chip" id="cursorCpuA">cpu -</div>
              <div class="thread-stat-chip" id="cursorMemA">mem -</div>
              <div class="hint" id="cursorKindA">A: waiting</div>
            </div>
          </div>
          <div class="cursor-thread-meta">
            <div class="cursor-thread-cfg" id="cursorCfgA">cfg -</div>
          </div>
          <div class="cursor-thread-controls">
            <button type="button" class="thread-ctl-btn" id="threadPauseA" title="Pause this worker process (SIGSTOP).">Pause</button>
            <button type="button" class="thread-ctl-btn" id="threadResumeA" title="Resume this worker process (SIGCONT).">Resume</button>
            <button type="button" class="thread-ctl-btn" id="threadRestartA" title="Restart this worker from checkpoint.">Restart</button>
          </div>
          <div class="stage-pipeline" id="cursorStagesA">
            <div class="stage-chip pending"><span>skip</span></div>
            <div class="stage-chip pending"><span>loop</span></div>
            <div class="stage-chip pending"><span>flux</span></div>
            <div class="stage-chip pending"><span>final</span></div>
          </div>
          <div class="cursor-pane-cursor">
            <canvas id="cursorCanvasA" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="cursorInfoA">Waiting for measurement cursor telemetry...</div>
          </div>
          <div class="cursor-pane-speed">
            <canvas id="speedCanvasA" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="speedInfoA">Waiting for speed samples...</div>
          </div>
        </div>
        <div class="cursor-thread-card">
          <div class="row">
            <div class="cursor-thread-title">Thread B</div>
            <div class="cursor-thread-top-right">
              <div class="thread-stat-chip" id="cursorBackendB">backend -</div>
              <div class="thread-stat-chip" id="cursorCpuB">cpu -</div>
              <div class="thread-stat-chip" id="cursorMemB">mem -</div>
              <div class="hint" id="cursorKindB">B: waiting</div>
            </div>
          </div>
          <div class="cursor-thread-meta">
            <div class="cursor-thread-cfg" id="cursorCfgB">cfg -</div>
          </div>
          <div class="cursor-thread-controls">
            <button type="button" class="thread-ctl-btn" id="threadPauseB" title="Pause this worker process (SIGSTOP).">Pause</button>
            <button type="button" class="thread-ctl-btn" id="threadResumeB" title="Resume this worker process (SIGCONT).">Resume</button>
            <button type="button" class="thread-ctl-btn" id="threadRestartB" title="Restart this worker from checkpoint.">Restart</button>
          </div>
          <div class="stage-pipeline" id="cursorStagesB">
            <div class="stage-chip pending"><span>skip</span></div>
            <div class="stage-chip pending"><span>loop</span></div>
            <div class="stage-chip pending"><span>flux</span></div>
            <div class="stage-chip pending"><span>final</span></div>
          </div>
          <div class="cursor-pane-cursor">
            <canvas id="cursorCanvasB" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="cursorInfoB">Waiting for measurement cursor telemetry...</div>
          </div>
          <div class="cursor-pane-speed">
            <canvas id="speedCanvasB" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="speedInfoB">Waiting for speed samples...</div>
          </div>
        </div>
        <div class="cursor-thread-card">
          <div class="row">
            <div class="cursor-thread-title">Thread C</div>
            <div class="cursor-thread-top-right">
              <div class="thread-stat-chip" id="cursorBackendC">backend -</div>
              <div class="thread-stat-chip" id="cursorCpuC">cpu -</div>
              <div class="thread-stat-chip" id="cursorMemC">mem -</div>
              <div class="hint" id="cursorKindC">C: waiting</div>
            </div>
          </div>
          <div class="cursor-thread-meta">
            <div class="cursor-thread-cfg" id="cursorCfgC">cfg -</div>
          </div>
          <div class="cursor-thread-controls">
            <button type="button" class="thread-ctl-btn" id="threadPauseC" title="Pause this worker process (SIGSTOP).">Pause</button>
            <button type="button" class="thread-ctl-btn" id="threadResumeC" title="Resume this worker process (SIGCONT).">Resume</button>
            <button type="button" class="thread-ctl-btn" id="threadRestartC" title="Restart this worker from checkpoint.">Restart</button>
          </div>
          <div class="stage-pipeline" id="cursorStagesC">
            <div class="stage-chip pending"><span>skip</span></div>
            <div class="stage-chip pending"><span>loop</span></div>
            <div class="stage-chip pending"><span>flux</span></div>
            <div class="stage-chip pending"><span>final</span></div>
          </div>
          <div class="cursor-pane-cursor">
            <canvas id="cursorCanvasC" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="cursorInfoC">Waiting for measurement cursor telemetry...</div>
          </div>
          <div class="cursor-pane-speed">
            <canvas id="speedCanvasC" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="speedInfoC">Waiting for speed samples...</div>
          </div>
        </div>
        <div class="cursor-thread-card">
          <div class="row">
            <div class="cursor-thread-title">Thread D</div>
            <div class="cursor-thread-top-right">
              <div class="thread-stat-chip" id="cursorBackendD">backend -</div>
              <div class="thread-stat-chip" id="cursorCpuD">cpu -</div>
              <div class="thread-stat-chip" id="cursorMemD">mem -</div>
              <div class="hint" id="cursorKindD">D: waiting</div>
            </div>
          </div>
          <div class="cursor-thread-meta">
            <div class="cursor-thread-cfg" id="cursorCfgD">cfg -</div>
          </div>
          <div class="cursor-thread-controls">
            <button type="button" class="thread-ctl-btn" id="threadPauseD" title="Pause this worker process (SIGSTOP).">Pause</button>
            <button type="button" class="thread-ctl-btn" id="threadResumeD" title="Resume this worker process (SIGCONT).">Resume</button>
            <button type="button" class="thread-ctl-btn" id="threadRestartD" title="Restart this worker from checkpoint.">Restart</button>
          </div>
          <div class="stage-pipeline" id="cursorStagesD">
            <div class="stage-chip pending"><span>skip</span></div>
            <div class="stage-chip pending"><span>loop</span></div>
            <div class="stage-chip pending"><span>flux</span></div>
            <div class="stage-chip pending"><span>final</span></div>
          </div>
          <div class="cursor-pane-cursor">
            <canvas id="cursorCanvasD" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="cursorInfoD">Waiting for measurement cursor telemetry...</div>
          </div>
          <div class="cursor-pane-speed">
            <canvas id="speedCanvasD" class="cursor-canvas cursor-canvas-thread" width="560" height="120"></canvas>
            <div class="hint cursor-thread-info" id="speedInfoD">Waiting for speed samples...</div>
          </div>
        </div>
      </div>
      <div class="speed-combined-wrap">
        <canvas id="speedCanvasAll" class="cursor-canvas speed-canvas-all" width="1140" height="220"></canvas>
        <div class="hint cursor-thread-info" id="speedInfoAll">Waiting for speed samples...</div>
      </div>
    </div>

    <div class="grid-3">
      <div class="card">
        <div class="metric-title">Elapsed</div>
        <div class="metric-value" id="elapsedVal">-</div>
      </div>
      <div class="card">
        <div class="metric-title">ETA</div>
        <div class="metric-value" id="etaVal">-</div>
      </div>
      <div class="card">
        <div class="metric-title">Plaquette</div>
        <div class="metric-value" id="plaqVal">-</div>
      </div>
    </div>

    <div class="card">
      <div class="row">
        <div class="metric-title">Thermalization Sweep Count</div>
        <div class="hint" id="thermSweepMeta">waiting for thermalization data</div>
      </div>
      <div class="metric-value" id="thermSweepCount">- / -</div>
      <div style="height: 8px;"></div>
      <div class="row"><div class="hint">Current sweep (estimated)</div><div class="hint" id="thermStepPct">0%</div></div>
      <div class="bar"><div class="fill sub-fill" id="thermStepFill"></div></div>
      <div class="hint" id="thermSweepHint">font color = overall thermalization progress (cold to hot)</div>
    </div>

    <div class="card">
      <div class="row">
        <div class="metric-title">Thread Status</div>
        <div class="hint" id="threadTableNote">seed group: -</div>
      </div>
      <div class="table-wrap">
        <table class="status-table">
          <thead>
            <tr>
              <th>Thread</th>
              <th>Seed</th>
              <th>Phase</th>
              <th>Therm</th>
              <th>Meas</th>
              <th>Cfg</th>
              <th>Cfg time</th>
              <th>CPU</th>
              <th>Memory</th>
              <th>Updated</th>
            </tr>
          </thead>
          <tbody id="threadStatusBody">
            <tr>
              <td colspan="10" class="hint">Waiting for progress files...</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="grid-2">
      <div class="chart-card">
        <div class="row">
          <div class="metric-title">Plaquette History</div>
          <div class="hint" id="historyCount">0 points</div>
        </div>
        <canvas id="plaqCanvas" width="560" height="220"></canvas>
        <div class="hint" id="plaqAxes">x: measurement index, y: plaquette running mean</div>
        <div id="plaqSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for plaquette history...</span></div>
      </div>
      <div class="chart-card">
        <div class="row">
          <div class="metric-title">Selected Wilson Loop (Re)</div>
          <div class="hint" id="loopKeyLabel">key: -</div>
        </div>
        <canvas id="loopCanvas" width="560" height="220"></canvas>
        <div class="hint" id="loopAxes">x: measurement index, y: running mean of Re W(R,T) for selected key</div>
        <div id="loopSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for loop history...</span></div>
      </div>
    </div>

    <div class="chart-card">
      <div class="row">
        <div class="metric-title">Flux Profile vs r⊥ (Mean ± SEM)</div>
        <div class="hint" id="fluxLabel">aggregated over measured configs</div>
      </div>
      <canvas id="fluxCanvas" width="1140" height="260"></canvas>
      <div class="hint" id="fluxAxes">x: r⊥ (lattice units), y: connected flux ΔP(r⊥)</div>
      <div id="fluxSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for flux signal diagnostics...</span></div>
      <div class="table-wrap">
        <table class="fit-table">
          <thead>
            <tr>
              <th>Flux Diagnostic</th>
              <th>Value</th>
              <th>Reference</th>
              <th>Agreement</th>
            </tr>
          </thead>
          <tbody id="fluxDiagBody">
            <tr><td colspan="4" class="hint">Flux diagnostics pending.</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="chart-card">
      <div class="row">
        <div class="metric-title">2Q Potential V(R) (Mean ± SEM)</div>
        <div class="hint" id="vLabel">V(R) unavailable</div>
      </div>
      <canvas id="vCanvas" width="1140" height="260"></canvas>
      <div class="hint" id="vAxes">x: R (lattice units), y: V(R)</div>
      <div class="hint" id="vFormula">Cornell: V(R)=V₀+σR−e/R | F(R)=dV/dR | r₀²F(r₀)=1.65 | r₁²F(r₁)=1.00 | R_c=√(e/σ)</div>
      <div id="vSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for potential fit diagnostics...</span></div>
      <div id="vTable" class="mono-list">No valid V(R) points yet.</div>
      <div class="table-wrap">
        <table class="fit-table">
          <thead>
            <tr>
              <th>Parameter</th>
              <th>Fit (lattice)</th>
              <th>Physical</th>
              <th>Reference</th>
              <th>Agreement</th>
            </tr>
          </thead>
          <tbody id="vFitBody">
            <tr><td colspan="5" class="hint">Cornell fit unavailable.</td></tr>
          </tbody>
        </table>
      </div>
      <div id="vForceTable" class="mono-list">Force diagnostics pending.</div>
    </div>

    <div class="grid-2">
      <div class="chart-card">
        <div class="row">
          <div class="metric-title">Plaquette Autocorrelation</div>
          <div class="hint" id="tauLabel">τ_int pending</div>
        </div>
        <canvas id="tauCanvas" width="560" height="220"></canvas>
        <div class="hint" id="tauAxes">x: lag (measurements), y: rho(lag) for plaquette</div>
        <div id="tauSignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for autocorrelation diagnostics...</span></div>
        <div id="tauSummary" class="mono-list">Waiting for measurement history...</div>
      </div>
      <div class="chart-card">
        <div class="row">
          <div class="metric-title">Polyakov Sectors</div>
          <div class="hint" id="polyLabel">Re P_mu pending</div>
        </div>
        <canvas id="polyCanvas" width="560" height="220"></canvas>
        <div class="hint" id="polyAxes">x: measurement index, y: Re Polyakov loop by mu</div>
        <div id="polySignal" class="signal-note"><span class="agreement-pill agreement-na">n/a</span><span class="signal-text">Waiting for Polyakov sector diagnostics...</span></div>
        <div id="polySummary" class="mono-list">Waiting for Polyakov-loop telemetry...</div>
      </div>
    </div>
  </div>

  <script>
    const pollMs = 1000;
    const streamStaleMs = 15000;
    const defaultAFm = 0.119;
    let paused = false;
    let loopKey = null;
    let eventSource = null;
    let usingStream = false;
    let lastStreamAt = 0;
    let currentProgress = null;
    let currentMeta = null;
    let currentMeasurements = [];
    let lastPotentialCompareRows = [];
    let lastFluxCompareRows = [];
    let lastRenderSignature = "";
    let chatHistory = [];
    let chatBusy = false;
    const progressStateBySeed = {};
    const progressOrderBySeed = {};
    const thermSweepStateBySeed = {};
    const threadProgressBySeed = {};
    const threadTelemetryBySeed = {};
    const threadCfgSpeedStateBySeed = {};
    const threadCfgSpeedHistoryBySeed = {};
    const measurementCacheBySeed = {};
    const cursorRenderStateByThread = {};
    const cursorMuStateByThread = {};
    const speedRenderStateByThread = {};
    const speedAxisState = { cfgSig: "", axisMax: 10 };
    const terminalPhaseSet = new Set([
      "interrupted",
      "complete",
      "done",
      "failed",
      "error",
      "aborted",
      "stopped",
    ]);
    const threadSlots = [
      { suffix: "", label: "A" },
      { suffix: "-b", label: "B" },
      { suffix: "-c", label: "C" },
      { suffix: "-d", label: "D" },
    ];
    const polyakovColorByMu = {
      mu0: "#52adff",
      mu1: "#2fd08a",
      mu2: "#f2c14b",
      mu3: "#f87171",
    };
    const threadStageDefs = [
      { key: "skip_sweeps", label: "skip" },
      { key: "measure_loops", label: "loop" },
      { key: "measure_flux", label: "flux" },
      { key: "finalize", label: "final" },
    ];
    const physicalReferenceCatalog = {
      luscher_1981: {
        index: 1,
        label: "M. Luscher, G. Munster, P. Weisz (1981) - String effects in the heavy quark potential.",
        url: "https://doi.org/10.1016/0550-3213(81)90592-5",
      },
      sommer_1994: {
        index: 2,
        label: "R. Sommer (1994) - A New way to set the energy scale in lattice gauge theories.",
        url: "https://arxiv.org/abs/hep-lat/9310022",
      },
      necco_sommer_2002: {
        index: 3,
        label: "S. Necco, R. Sommer (2002) - The Nf=0 heavy quark potential from short to intermediate distances.",
        url: "https://arxiv.org/abs/hep-lat/0108008",
      },
      bazavov_2010: {
        index: 4,
        label: "A. Bazavov et al. (2010) - Results for light pseudoscalar mesons (includes r1 scale benchmark).",
        url: "https://arxiv.org/abs/1004.0342",
      },
    };
    const threadStageActiveOrder = threadStageDefs.map((x) => x.key);
    let threadStatusBusy = false;
    let threadStatusNextAtMs = 0;
    let threadTelemetryBusy = false;
    let threadTelemetryNextAtMs = 0;
    let threadControlBusy = false;

    function setStreamStatus(text) {
      document.getElementById("streamStatus").textContent = text;
    }

    function setChatStatus(text) {
      document.getElementById("chatStatus").textContent = text;
    }

    function addChat(role, text) {
      const log = document.getElementById("chatLog");
      const row = document.createElement("div");
      row.className = `chat-row chat-${role}`;
      const label = role === "user" ? "You" : (role === "assistant" ? "Assistant" : "System");
      row.textContent = `${label}: ${text}`;
      log.appendChild(row);
      log.scrollTop = log.scrollHeight;
    }

    async function sendChat() {
      if (chatBusy) return;
      const input = document.getElementById("chatInput");
      const text = (input.value || "").trim();
      if (!text) return;
      input.value = "";
      chatHistory.push({ role: "user", content: text });
      addChat("user", text);
      chatBusy = true;
      setChatStatus("chat: sending...");
      const token = (document.getElementById("authToken").value || "").trim();
      try {
        const r = await fetch(withApiBase("/chat"), {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...(token ? { "X-Auth-Token": token } : {}),
          },
          body: JSON.stringify({ messages: chatHistory, ...(token ? { token } : {}) }),
        });
        const payload = await r.json();
        if (!r.ok) {
          const err = payload.error || `${r.status} ${r.statusText}`;
          addChat("system", `Error: ${err}`);
          setChatStatus("chat: unavailable");
          return;
        }
        const reply = (payload.reply || "").trim() || "(empty reply)";
        chatHistory.push({ role: "assistant", content: reply });
        addChat("assistant", reply);
        setChatStatus("chat: ready");
      } catch (e) {
        addChat("system", `Network error: ${e.message}`);
        setChatStatus("chat: unavailable");
      } finally {
        chatBusy = false;
      }
    }

    function applyUrlDefaults() {
      const params = new URLSearchParams(window.location.search);
      const seed = params.get("seed");
      const progress = params.get("progress");
      const live = params.get("live");
      const token = params.get("token");
      const api = params.get("api");
      const aFm = params.get("a_fm") || params.get("a") || params.get("afm");
      const legacyFilter = params.get("legacy_filter");
      const combineParam = params.get("combine");

      const progressEl = document.getElementById("progressPath");
      const liveEl = document.getElementById("livePath");

      if (seed) {
        progressEl.value = `/results/su2_signal_scan/progress_${seed}.json`;
        liveEl.value = `/results/su2_signal_scan/live_${seed}.json`;
      }
      if (progress) progressEl.value = progress;
      if (live) liveEl.value = live;
      if (token) document.getElementById("authToken").value = token;
      if (api) {
        document.getElementById("apiBase").value = api;
      } else if (window.location.port === "8000") {
        document.getElementById("apiBase").value = "http://127.0.0.1:8001";
      }
      if (aFm) document.getElementById("aFmInput").value = aFm;
      if (legacyFilter !== null) {
        document.getElementById("legacyFilter").checked =
          legacyFilter === "1" || legacyFilter === "true" || legacyFilter === "yes";
      } else {
        // Default to improved estimator.
        document.getElementById("legacyFilter").checked = false;
      }
      if (combineParam !== null) {
        document.getElementById("combineSeeds").checked =
          combineParam === "1" || combineParam === "true" || combineParam === "yes";
      }
    }

    function normalizePath(path) {
      const p = (path || "").trim();
      if (!p) return p;
      if (p.startsWith("http://") || p.startsWith("https://")) return p;
      if (p.startsWith("/")) return p;
      return `/${p.replace(/^\.\//, "")}`;
    }

    function escapeHtml(v) {
      return String(v ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function renderTargetWithRefsHtml(row) {
      const base = escapeHtml(row?.target || row?.reference || "-");
      const refIds = Array.isArray(row?.refs) ? row.refs : [];
      if (refIds.length === 0) return base;
      const supers = [];
      for (const refId of refIds) {
        const key = String(refId || "");
        const ref = physicalReferenceCatalog[key];
        if (!ref) continue;
        const idx = Number(ref.index);
        if (!(Number.isFinite(idx) && idx > 0)) continue;
        const targetId = `phys-ref-${idx}`;
        supers.push(`<sup class="target-ref"><a href="#${targetId}" title="Reference [${idx}]">${idx}</a></sup>`);
      }
      return `${base}${supers.join("")}`;
    }

    function renderPhysicalReferenceList(rows) {
      const listEl = document.getElementById("physicalRefList");
      if (!listEl) return;
      const used = new Set();
      for (const row of (rows || [])) {
        const refIds = Array.isArray(row?.refs) ? row.refs : [];
        for (const refId of refIds) {
          const key = String(refId || "");
          if (physicalReferenceCatalog[key]) used.add(key);
        }
      }
      const ordered = Array.from(used).sort((a, b) => {
        const ia = Number(physicalReferenceCatalog[a]?.index || Infinity);
        const ib = Number(physicalReferenceCatalog[b]?.index || Infinity);
        return ia - ib;
      });
      if (ordered.length === 0) {
        listEl.innerHTML = "";
        return;
      }
      listEl.innerHTML = ordered.map((key) => {
        const ref = physicalReferenceCatalog[key];
        const idx = Number(ref.index);
        return `<li id="phys-ref-${idx}">[${idx}] ${escapeHtml(ref.label)} <a href="${escapeHtml(ref.url)}" target="_blank" rel="noopener">link</a></li>`;
      }).join("");
    }

    function inferSeedFromProgressPath(path) {
      const p = normalizePath(path || "");
      const m = p.match(/progress_([^/]+)\.json$/i);
      return m ? m[1] : "";
    }

    function inferSeedFromLivePath(path) {
      const p = normalizePath(path || "");
      const m = p.match(/live_([^/]+)\.json$/i);
      return m ? m[1] : "";
    }

    function resolveLiveSeed(live, livePath = "") {
      const fromMeta = String(live?.meta?.seed || "").trim();
      if (fromMeta) return fromMeta;
      const fromProgress = String(currentProgress?.seed || "").trim();
      if (fromProgress) return fromProgress;
      return inferSeedFromLivePath(livePath);
    }

    function cacheLiveMeasurements(seed, measurements) {
      const k = String(seed || "").trim();
      if (!k || !Array.isArray(measurements) || measurements.length === 0) return;
      measurementCacheBySeed[k] = measurements;
    }

    function applyCachedMeasurements(livePath, live) {
      if (!live || typeof live !== "object") return live;
      const seed = resolveLiveSeed(live, livePath);
      const ms = Array.isArray(live.measurements) ? live.measurements : [];
      if (ms.length > 0) {
        cacheLiveMeasurements(seed, ms);
        return live;
      }
      const cached = measurementCacheBySeed[seed];
      if (Array.isArray(cached) && cached.length > 0) {
        return { ...live, measurements: cached };
      }
      return live;
    }

    function parseJsonlMeasurements(text) {
      const rows = [];
      if (typeof text !== "string" || text.length === 0) return rows;
      for (const raw of text.split(/\r?\n/)) {
        const line = raw.trim();
        if (!line) continue;
        try {
          const row = JSON.parse(line);
          if (row && typeof row === "object") rows.push(row);
        } catch (_) {
          // Ignore partial/truncated append lines.
        }
      }
      return rows;
    }

    function deriveJsonlPath(livePath, live) {
      const p = normalizePath(livePath || "");
      if (!p) return "";
      const fromMeta = String(live?.meta?.jsonl_path || "").trim();
      if (fromMeta) {
        if (fromMeta.startsWith("http://") || fromMeta.startsWith("https://")) return fromMeta;
        if (fromMeta.startsWith("/")) return normalizePath(fromMeta);
        const slash = p.lastIndexOf("/");
        const parent = slash >= 0 ? p.slice(0, slash + 1) : "/";
        return normalizePath(`${parent}${fromMeta}`);
      }
      return p.replace(/\.json$/i, ".jsonl");
    }

    function deriveCheckpointPath(livePath, live) {
      const p = normalizePath(livePath || "");
      if (!p) return "";
      const seed = resolveLiveSeed(live, p);
      if (!seed) return "";
      const slash = p.lastIndexOf("/");
      const parent = slash >= 0 ? p.slice(0, slash + 1) : "/";
      return normalizePath(`${parent}checkpoint_${seed}.json`);
    }

    function baseSeed(seed) {
      return String(seed || "").replace(/-(b|c|d)$/i, "");
    }

    function latestLoadedThreadBaseSeed() {
      let bestSeed = "";
      let bestTs = -Infinity;
      for (const [seed, p] of Object.entries(threadProgressBySeed)) {
        const ts = Date.parse(p?.timestamp_utc || "");
        const score = Number.isFinite(ts) ? ts : -Infinity;
        if (score > bestTs && seed) {
          bestTs = score;
          bestSeed = seed;
        }
      }
      return baseSeed(bestSeed);
    }

    function resolveThreadBaseSeed() {
      const fromCurrent = baseSeed(currentProgress?.seed || "");
      if (fromCurrent) return fromCurrent;
      const fromLoaded = latestLoadedThreadBaseSeed();
      if (fromLoaded) return fromLoaded;
      const progressPath = document.getElementById("progressPath")?.value || "";
      const fromPath = baseSeed(inferSeedFromProgressPath(progressPath));
      return fromPath || "petrus-su2-signal";
    }

    function threadCursorEntries(fallbackProgress = null) {
      const rootSeed = resolveThreadBaseSeed();
      return threadSlots.map((slot) => {
        const seed = `${rootSeed}${slot.suffix}`;
        const progress = threadProgressBySeed[seed] || (fallbackProgress?.seed === seed ? fallbackProgress : null);
        return { slot, seed, progress: progress || null };
      });
    }

    function aggregateThreadMeasurementCounters(fallbackProgress = null) {
      const entries = threadCursorEntries(fallbackProgress);
      let done = 0;
      let total = 0;
      let active = 0;
      for (const entry of entries) {
        const p = entry?.progress || null;
        const n = toFiniteNumber(p?.nmeas, NaN);
        const d = toFiniteNumber(p?.meas_done, NaN);
        if (!(Number.isFinite(n) && n > 0 && Number.isFinite(d))) continue;
        done += Math.max(0, Math.min(n, d));
        total += n;
        active += 1;
      }
      if (!(active > 1 && total > 0)) return null;
      return { done, total, active };
    }

    function renderMeasurementCounter(fallbackProgress = null, doneHint = NaN, totalHint = NaN) {
      const el = document.getElementById("measCounterDetail");
      if (!el) return;
      const entries = threadCursorEntries(fallbackProgress);
      const parts = [];
      let sumDone = 0;
      let sumTotal = 0;
      let active = 0;
      for (const entry of entries) {
        const label = String(entry?.slot?.label || "?");
        const p = entry?.progress || null;
        const n = toFiniteNumber(p?.nmeas, NaN);
        const d = toFiniteNumber(p?.meas_done, NaN);
        if (Number.isFinite(n) && n > 0 && Number.isFinite(d)) {
          const done = Math.max(0, Math.min(n, d));
          const total = Math.max(0, n);
          parts.push(`${label}=${Math.round(done)}/${Math.round(total)}`);
          sumDone += done;
          sumTotal += total;
          active += 1;
        } else {
          parts.push(`${label}=-`);
        }
      }
      const done = Number.isFinite(doneHint) ? Math.max(0, doneHint) : (active > 0 ? sumDone : NaN);
      const total = Number.isFinite(totalHint) ? Math.max(0, totalHint) : (active > 0 ? sumTotal : NaN);
      const overallText = Number.isFinite(done) && Number.isFinite(total) && total > 0
        ? `${Math.round(done)} / ${Math.round(total)}`
        : "- / -";
      el.textContent = `N_meas = ${overallText} (${parts.join(", ")})`;
    }

    function threadPhaseBadge(phaseRaw, doneFlag) {
      const phase = String(phaseRaw || "").toLowerCase();
      if (doneFlag || phase === "done" || phase === "complete") return { label: "Complete", cls: "phase-done" };
      if (phase === "thermalization") return { label: "Thermalizing", cls: "phase-therm" };
      if (phase === "production") return { label: "Measuring", cls: "phase-meas" };
      if (phase === "initializing") return { label: "Starting", cls: "phase-init" };
      if (terminalPhaseSet.has(phase)) return { label: "Stopped", cls: "phase-stop" };
      if (!phase) return { label: "Unknown", cls: "phase-unknown" };
      return { label: `${phase[0].toUpperCase()}${phase.slice(1)}`, cls: "phase-unknown" };
    }

    function fmtDoneTotal(done, total) {
      const d = toFiniteNumber(done, NaN);
      const t = toFiniteNumber(total, NaN);
      if (!Number.isFinite(d) || !Number.isFinite(t) || t < 0) return "-";
      return `${Math.round(d)} / ${Math.round(t)}`;
    }

    function fmtThreadCfgIndex(p, meta = null) {
      const phase = String(p?.phase || "").toLowerCase();
      const nmeas = toFiniteNumber(p?.nmeas, NaN);
      if (p?.done || phase === "complete" || phase === "done") {
        return Number.isFinite(nmeas) && nmeas > 0 ? `${Math.round(nmeas)} (done)` : "done";
      }
      const snap = configStageSnapshot(p, meta);
      const idx = Math.round(toFiniteNumber(snap?.cfgIdx, NaN));
      if (Number.isFinite(idx) && idx > 0) return `${idx}`;
      return "-";
    }

    function fmtUpdated(ts) {
      const ms = Date.parse(ts || "");
      return Number.isFinite(ms) ? new Date(ms).toLocaleTimeString() : "-";
    }

    function getThreadVizMode() {
      const v = String(document.getElementById("threadVizMode")?.value || "cursor").toLowerCase();
      return v === "speed" ? "speed" : "cursor";
    }

    function applyThreadVizMode() {
      const card = document.getElementById("threadVizCard");
      if (!card) return;
      const mode = getThreadVizMode();
      card.classList.toggle("cursor-mode-speed", mode === "speed");
    }

    function threadCfgPositionSnapshot(p, meta = null) {
      const snap = configStageSnapshot(p, meta);
      if (!snap) return null;
      const cfgIdxRaw = toFiniteNumber(snap.cfgIdx, NaN);
      const cfgProgressRaw = toFiniteNumber(snap.progress, NaN);
      if (!Number.isFinite(cfgIdxRaw) || !Number.isFinite(cfgProgressRaw)) return null;
      const cfgIdx = Math.max(1, Math.round(cfgIdxRaw));
      const cfgProgress = clamp01(cfgProgressRaw);
      return {
        cfgIdx,
        cfgProgress,
        cfgPos: Math.max(0, cfgIdx - 1 + cfgProgress),
      };
    }

    function estimateLiveCfgProgress(seed, cfgIdx, cfgProgress, tsMs, inProduction = true) {
      const base = toFiniteNumber(cfgProgress, NaN);
      if (!Number.isFinite(base)) return NaN;
      // Show exact reported progress sample (no client-side interpolation).
      return clamp01(base);
    }

    function stabilizeDisplayedCfgProgress(seed, cfgIdx, progress, inProduction = true) {
      const p = toFiniteNumber(progress, NaN);
      if (!Number.isFinite(p)) return p;
      // Show exact telemetry sample; no forward-only display smoothing.
      return clamp01(p);
    }

    function pruneThreadCfgSpeedHistory(seed, currentCfgIdx) {
      const k = String(seed || "");
      if (!k || !Array.isArray(threadCfgSpeedHistoryBySeed[k])) return;
      const hist = threadCfgSpeedHistoryBySeed[k];
      if (hist.length <= 2000) return;

      const curIdx = Number.isFinite(currentCfgIdx) ? Math.round(currentCfgIdx) : NaN;
      const keepCurrent = [];
      const keepOlder = [];
      for (const item of hist) {
        const idx = Math.round(toFiniteNumber(item?.cfgIdx, NaN));
        if (Number.isFinite(curIdx) && Number.isFinite(idx) && idx === curIdx) {
          keepCurrent.push(item);
        } else {
          keepOlder.push(item);
        }
      }

      const olderTail = keepOlder.slice(Math.max(0, keepOlder.length - 320));
      threadCfgSpeedHistoryBySeed[k] = olderTail.concat(keepCurrent);
    }

    function estimateThreadCfgSeconds(seed, p = null, meta = null) {
      const k = String(seed || "");
      if (!k) return NaN;
      const prev = threadCfgSpeedStateBySeed[k] || {
        cfgPos: NaN,
        cfgIdx: NaN,
        cfgProgress: NaN,
        tsMs: NaN,
        secPerCfg: NaN,
        cfgAnchorIdx: NaN,
        cfgAnchorPos: NaN,
        cfgAnchorTsMs: NaN,
        rawTsMs: NaN,
        rawCfgProgress: NaN,
        cfgRatePerSec: NaN,
      };
      if (!p) return prev.secPerCfg;

      const pos = threadCfgPositionSnapshot(p, meta);
      const tsMs = Date.parse(p?.timestamp_utc || "");
      let secPerCfg = prev.secPerCfg;
      let cfgAnchorIdx = prev.cfgAnchorIdx;
      let cfgAnchorPos = prev.cfgAnchorPos;
      let cfgAnchorTsMs = prev.cfgAnchorTsMs;
      let rawTsMs = prev.rawTsMs;
      let rawCfgProgress = prev.rawCfgProgress;
      let cfgRatePerSec = prev.cfgRatePerSec;

      if (pos && Number.isFinite(tsMs)) {
        const cfgChanged =
          !Number.isFinite(cfgAnchorIdx) ||
          pos.cfgIdx !== cfgAnchorIdx ||
          (Number.isFinite(prev.tsMs) && tsMs + 1 < prev.tsMs);
        if (cfgChanged) {
          cfgAnchorIdx = pos.cfgIdx;
          cfgAnchorPos = Math.max(0, pos.cfgIdx - 1);
          cfgAnchorTsMs = tsMs;
          rawTsMs = tsMs;
          rawCfgProgress = pos.cfgProgress;
        }

        const hasNewProgressSample =
          cfgChanged ||
          !Number.isFinite(prev.tsMs) ||
          tsMs > prev.tsMs + 1;
        if (hasNewProgressSample) {
          const wrapped =
            Number.isFinite(prev.cfgProgress) &&
            (pos.cfgProgress + 1e-4) < prev.cfgProgress;
          if (wrapped) {
            rawTsMs = tsMs;
            rawCfgProgress = pos.cfgProgress;
          } else if (Number.isFinite(rawTsMs) && Number.isFinite(rawCfgProgress) && tsMs > rawTsMs + 1) {
            const dProg = pos.cfgProgress - rawCfgProgress;
            const dSec = (tsMs - rawTsMs) / 1000.0;
            if (Number.isFinite(dProg) && Number.isFinite(dSec) && dProg >= 0 && dSec > 0) {
              const instRate = dProg / dSec;
              if (Number.isFinite(instRate) && instRate > 0) {
                cfgRatePerSec = Number.isFinite(cfgRatePerSec)
                  ? (0.35 * cfgRatePerSec + 0.65 * instRate)
                  : instRate;
              }
            }
            rawTsMs = tsMs;
            rawCfgProgress = pos.cfgProgress;
          } else {
            rawTsMs = tsMs;
            rawCfgProgress = pos.cfgProgress;
          }
        }
        if (hasNewProgressSample && Number.isFinite(cfgAnchorPos) && Number.isFinite(cfgAnchorTsMs) && tsMs >= cfgAnchorTsMs) {
          const deltaCfg = pos.cfgPos - cfgAnchorPos;
          const deltaSec = (tsMs - cfgAnchorTsMs) / 1000.0;
          if (Number.isFinite(deltaCfg) && Number.isFinite(deltaSec) && deltaCfg > 1e-6 && deltaSec > 0) {
            const sampleFromCfgStart = deltaSec / deltaCfg;
            secPerCfg = Number.isFinite(secPerCfg) ? (0.35 * secPerCfg + 0.65 * sampleFromCfgStart) : sampleFromCfgStart;
            if (!Array.isArray(threadCfgSpeedHistoryBySeed[k])) threadCfgSpeedHistoryBySeed[k] = [];
            const hist = threadCfgSpeedHistoryBySeed[k];
            const last = hist.length > 0 ? hist[hist.length - 1] : null;
            if (!last || pos.cfgIdx !== last.cfgIdx || tsMs > last.tsMs + 1) {
              hist.push({
                tsMs,
                secPerCfg: sampleFromCfgStart,
                secPerCfgSmooth: secPerCfg,
                cfgPos: pos.cfgPos,
                cfgIdx: pos.cfgIdx,
                cfgProgress: pos.cfgProgress,
              });
              pruneThreadCfgSpeedHistory(k, pos.cfgIdx);
            }
          }
        }
      }

      threadCfgSpeedStateBySeed[k] = {
        cfgPos: pos && Number.isFinite(pos.cfgPos) ? pos.cfgPos : prev.cfgPos,
        cfgIdx: pos && Number.isFinite(pos.cfgIdx) ? pos.cfgIdx : prev.cfgIdx,
        cfgProgress: pos && Number.isFinite(pos.cfgProgress) ? pos.cfgProgress : prev.cfgProgress,
        tsMs: Number.isFinite(tsMs) ? tsMs : prev.tsMs,
        secPerCfg,
        cfgAnchorIdx: Number.isFinite(cfgAnchorIdx) ? cfgAnchorIdx : prev.cfgAnchorIdx,
        cfgAnchorPos: Number.isFinite(cfgAnchorPos) ? cfgAnchorPos : prev.cfgAnchorPos,
        cfgAnchorTsMs: Number.isFinite(cfgAnchorTsMs) ? cfgAnchorTsMs : prev.cfgAnchorTsMs,
        rawTsMs: Number.isFinite(rawTsMs) ? rawTsMs : prev.rawTsMs,
        rawCfgProgress: Number.isFinite(rawCfgProgress) ? rawCfgProgress : prev.rawCfgProgress,
        cfgRatePerSec: Number.isFinite(cfgRatePerSec) ? cfgRatePerSec : prev.cfgRatePerSec,
      };
      return secPerCfg;
    }

    function fmtCfgSeconds(secPerCfg) {
      const v = Number(secPerCfg);
      if (!Number.isFinite(v) || v <= 0) return "-";
      if (v < 60) return `${v.toFixed(1)} s/cfg`;
      return `${(v / 60).toFixed(1)} min/cfg`;
    }

    function getThreadCurrentCfgSpeedSeries(seed) {
      const k = String(seed || "");
      const st = threadCfgSpeedStateBySeed[k] || {};
      const cfgIdx = Number.isFinite(toFiniteNumber(st.cfgIdx, NaN)) ? Math.round(st.cfgIdx) : NaN;
      const anchorTsMs = toFiniteNumber(st.cfgAnchorTsMs, NaN);
      const history = Array.isArray(threadCfgSpeedHistoryBySeed[k]) ? threadCfgSpeedHistoryBySeed[k] : [];
      const filtered = Number.isFinite(cfgIdx)
        ? history.filter((x) => Math.round(toFiniteNumber(x?.cfgIdx, NaN)) === cfgIdx)
        : history;
      let points = filtered
        .map((x) => {
          const tsMs = toFiniteNumber(x?.tsMs, NaN);
          const sec = toFiniteNumber(x?.secPerCfg, NaN);
          if (!Number.isFinite(tsMs) || !Number.isFinite(sec) || sec <= 0) return null;
          const xSec = Number.isFinite(anchorTsMs) ? Math.max(0, (tsMs - anchorTsMs) / 1000.0) : NaN;
          if (!Number.isFinite(xSec)) return null;
          return { xSec, sec, tsMs };
        })
        .filter(Boolean);
      if (points.length > 0 && points[0].xSec > 1e-6) {
        points = [{ xSec: 0, sec: points[0].sec, tsMs: points[0].tsMs }, ...points];
      }
      const currentSec = toFiniteNumber(st.secPerCfg, NaN);
      if (points.length === 0 && Number.isFinite(currentSec)) {
        points = [{ xSec: 0, sec: currentSec, tsMs: anchorTsMs }];
      }
      if (points.length > 0 && Number.isFinite(anchorTsMs) && Number.isFinite(currentSec)) {
        const nowMs = Date.now();
        const xNow = Math.max(0, (nowMs - anchorTsMs) / 1000.0);
        const last = points[points.length - 1];
        const lastX = toFiniteNumber(last?.xSec, NaN);
        // Keep the line extending between sparse progress-file writes.
        if (Number.isFinite(xNow) && (!Number.isFinite(lastX) || xNow > lastX + 0.2)) {
          points = [...points, { xSec: xNow, sec: currentSec, tsMs: nowMs }];
        }
      }
      return {
        cfgIdx,
        points,
        currentSec,
      };
    }

    function computeSpeedYAxisMax(entries = []) {
      let maxV = NaN;
      const cfgBits = [];
      for (const entry of entries) {
        const seed = String(entry?.seed || "");
        if (!seed) continue;
        const series = getThreadCurrentCfgSpeedSeries(seed);
        const cfgIdx = Number.isFinite(series.cfgIdx) ? Math.round(series.cfgIdx) : "na";
        cfgBits.push(`${seed}:${cfgIdx}`);
        for (const point of series.points) {
          const v = toFiniteNumber(point?.sec, NaN);
          if (Number.isFinite(v) && v > 0) {
            maxV = Number.isFinite(maxV) ? Math.max(maxV, v) : v;
          }
        }
        if (Number.isFinite(series.currentSec) && series.currentSec > 0) {
          maxV = Number.isFinite(maxV) ? Math.max(maxV, series.currentSec) : series.currentSec;
        }
      }

      const cfgSig = cfgBits.join("|");
      const targetMax = Number.isFinite(maxV)
        ? Math.max(10, 2 * Math.ceil((maxV * 1.10) / 2))
        : 10;

      if (speedAxisState.cfgSig !== cfgSig) {
        speedAxisState.cfgSig = cfgSig;
        speedAxisState.axisMax = targetMax;
      } else if (targetMax > speedAxisState.axisMax) {
        // Grow within a config, never shrink (prevents jittery axis rescaling).
        speedAxisState.axisMax = targetMax;
      }
      return Math.max(2, speedAxisState.axisMax);
    }

    function threadStatusCfgPosForCompare(p) {
      const snap = threadCfgPositionSnapshot(p, currentMeta);
      return Number.isFinite(toFiniteNumber(snap?.cfgPos, NaN)) ? snap.cfgPos : NaN;
    }

    function shouldAcceptThreadProgress(seed, candidate) {
      if (!candidate) return false;
      const k = String(seed || candidate?.seed || "");
      const prev = k ? threadProgressBySeed[k] : null;
      if (!prev) return true;

      const nextTs = Date.parse(candidate?.timestamp_utc || "");
      const prevTs = Date.parse(prev?.timestamp_utc || "");
      if (Number.isFinite(nextTs) && Number.isFinite(prevTs)) {
        if (nextTs + 1 < prevTs) return false;
        if (Math.abs(nextTs - prevTs) <= 1) {
          const nextPos = threadStatusCfgPosForCompare(candidate);
          const prevPos = threadStatusCfgPosForCompare(prev);
          if (Number.isFinite(nextPos) && Number.isFinite(prevPos) && nextPos + 1e-6 < prevPos) {
            return false;
          }
        }
      } else if (!Number.isFinite(nextTs) && Number.isFinite(prevTs)) {
        return false;
      }
      return true;
    }

    function applyThreadTelemetryMap(map) {
      if (!map || typeof map !== "object") return;
      for (const [seed, row] of Object.entries(map)) {
        const k = String(seed || "").trim();
        if (!k || !row || typeof row !== "object") continue;
        threadTelemetryBySeed[k] = row;
      }
    }

    function threadTelemetryForSeed(seed, p = null) {
      const k = String(seed || p?.seed || "").trim();
      if (!k) return null;
      const fromMap = threadTelemetryBySeed[k];
      if (fromMap && fromMap.found !== false) return fromMap;
      const embedded = p?.thread_telemetry;
      if (embedded && typeof embedded === "object" && embedded.found !== false) return embedded;
      return null;
    }

    function normalizeComputeBackend(value) {
      const txt = String(value || "").trim().toLowerCase();
      if (!txt) return "";
      if (txt.includes("gpu")) return "gpu";
      if (txt.includes("cpu")) return "cpu";
      return txt;
    }

    function resolveComputeSummary(progress, meta, telemetry = null) {
      const p = progress || {};
      const m = meta || {};
      let backend = normalizeComputeBackend(p.compute_backend || m.compute_backend || "");
      const acceleration = String(p.grid_acceleration || m.grid_acceleration || "").trim();
      const simd = String(p.grid_simd || m.grid_simd || "").trim();
      let pipeline = String(p.compute_pipeline || m.compute_pipeline || telemetry?.pipeline || "").trim().toLowerCase();
      if (!pipeline) pipeline = "auto";
      if (!backend && (pipeline === "cpu" || pipeline === "gpu")) backend = pipeline;
      return { backend, acceleration, simd, pipeline };
    }

    function formatComputeSummary(summary, opts = {}) {
      const short = Boolean(opts.short);
      if (!summary || typeof summary !== "object") return "-";
      const backend = summary.backend ? summary.backend.toUpperCase() : "";
      const acceleration = String(summary.acceleration || "").trim();
      const simd = String(summary.simd || "").trim();
      const pipeline = String(summary.pipeline || "").trim().toLowerCase();
      if (!backend && !acceleration && !simd && !pipeline) return "-";
      if (short) {
        let out = backend || (pipeline ? pipeline.toUpperCase() : (acceleration ? "ACCEL" : "-"));
        if (acceleration) out += `/${acceleration}`;
        if (pipeline && pipeline !== "auto") out += ` (${pipeline})`;
        return out;
      }
      const parts = [];
      parts.push(backend || "unknown");
      if (acceleration) parts.push(`accel=${acceleration}`);
      if (simd) parts.push(`SIMD=${simd}`);
      if (pipeline) parts.push(`pipeline=${pipeline}`);
      return parts.join(", ");
    }

    function fmtThreadCpu(telemetry) {
      const cpu = toFiniteNumber(telemetry?.cpu_pct, NaN);
      if (!Number.isFinite(cpu)) return "-";
      return `${cpu.toFixed(1)}%`;
    }

    function fmtThreadMem(telemetry) {
      const rssMb = toFiniteNumber(telemetry?.rss_mb, NaN);
      const rssKb = toFiniteNumber(telemetry?.rss_kb, NaN);
      const mb = Number.isFinite(rssMb) ? rssMb : (Number.isFinite(rssKb) ? (rssKb / 1024.0) : NaN);
      if (!Number.isFinite(mb)) return "-";
      return `${mb.toFixed(0)} MB`;
    }

    function fmtThreadPid(telemetry) {
      const pid = Math.round(toFiniteNumber(telemetry?.pid, NaN));
      return Number.isFinite(pid) && pid > 0 ? `pid ${pid}` : "";
    }

    async function refreshThreadTelemetry(baseSeedName, force = false) {
      const root = baseSeed(baseSeedName);
      if (!root) return;
      const now = Date.now();
      if (!force && (threadTelemetryBusy || now < threadTelemetryNextAtMs)) return;
      threadTelemetryBusy = true;
      threadTelemetryNextAtMs = now + 1000;
      try {
        const payload = await fetchJson(`/thread_telemetry?base_seed=${encodeURIComponent(root)}`);
        if (payload?.threads && typeof payload.threads === "object") {
          applyThreadTelemetryMap(payload.threads);
        }
      } catch (_) {
        // Keep last known telemetry when endpoint is unavailable.
      } finally {
        threadTelemetryBusy = false;
      }
    }

    function threadStatusUnavailableRow(slot) {
      return `<tr>
        <td>${escapeHtml(slot.label)}</td>
        <td>${escapeHtml(slot.seed)}</td>
        <td><span class="phase-pill phase-unknown">Unavailable</span></td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
      </tr>`;
    }

    function threadStatusRow(slot, p, accepted = true) {
      const phase = threadPhaseBadge(p?.phase, Boolean(p?.done));
      const cfgCell = fmtThreadCfgIndex(p, currentMeta);
      const cfgSec = estimateThreadCfgSeconds(slot.seed, p, currentMeta);
      const telemetry = threadTelemetryForSeed(slot.seed, p);
      const cpuCell = telemetry ? fmtThreadCpu(telemetry) : "-";
      const memCell = telemetry ? fmtThreadMem(telemetry) : "-";
      const pidTxt = telemetry ? fmtThreadPid(telemetry) : "";
      const updatedTxt = fmtUpdated(p?.timestamp_utc);
      const phaseLabel = accepted ? phase.label : `${phase.label} (stale)`;
      const updatedCell = accepted ? updatedTxt : (updatedTxt === "-" ? "-" : `${updatedTxt} (stale)`);
      return `<tr>
        <td>${escapeHtml(slot.label)}</td>
        <td>${escapeHtml(slot.seed)}</td>
        <td><span class="phase-pill ${phase.cls}">${escapeHtml(phaseLabel)}</span></td>
        <td>${escapeHtml(fmtDoneTotal(p?.therm_done, p?.ntherm))}</td>
        <td>${escapeHtml(fmtDoneTotal(p?.meas_done, p?.nmeas))}</td>
        <td>${escapeHtml(cfgCell)}</td>
        <td>${escapeHtml(fmtCfgSeconds(cfgSec))}</td>
        <td title="${escapeHtml(pidTxt)}">${escapeHtml(cpuCell)}</td>
        <td>${escapeHtml(memCell)}</td>
        <td>${escapeHtml(updatedCell)}</td>
      </tr>`;
    }

    async function refreshThreadStatusTable(force = false) {
      const now = Date.now();
      if (!force && (threadStatusBusy || now < threadStatusNextAtMs)) return;
      const tbody = document.getElementById("threadStatusBody");
      const note = document.getElementById("threadTableNote");
      if (!tbody || !note) return;

      threadStatusBusy = true;
      threadStatusNextAtMs = now + 1000;
      try {
        const rootSeed = resolveThreadBaseSeed();
        note.textContent = `seed group: ${rootSeed}{,-b,-c,-d}`;
        const seeds = threadSlots.map((slot) => ({ ...slot, seed: `${rootSeed}${slot.suffix}` }));
        const telemetryPromise = refreshThreadTelemetry(rootSeed, force);
        const streamFresh = usingStream && (Date.now() - lastStreamAt) <= streamStaleMs;
        const haveAllStreamThreads = seeds.every((slot) => Boolean(threadProgressBySeed[slot.seed]));
        if (!force && streamFresh && haveAllStreamThreads) {
          await telemetryPromise;
          const rows = seeds.map((slot) => {
            const p = threadProgressBySeed[slot.seed] || null;
            return p ? threadStatusRow(slot, p, true) : threadStatusUnavailableRow(slot);
          });
          tbody.innerHTML = rows.join("");
          renderThreadCursors(currentProgress);
          return;
        }
        const loadedBySeed = {};
        const rows = await Promise.all(seeds.map(async (slot) => {
          const path = `/results/su2_signal_scan/progress_${slot.seed}.json`;
          try {
            const fetched = await fetchJson(path);
            const accepted = shouldAcceptThreadProgress(slot.seed, fetched);
            const cached = threadProgressBySeed[slot.seed] || null;
            const p = accepted ? fetched : (cached || fetched);
            loadedBySeed[slot.seed] = accepted ? fetched : null;
            return threadStatusRow(slot, p, accepted);
          } catch (_) {
            loadedBySeed[slot.seed] = null;
            const cached = threadProgressBySeed[slot.seed] || null;
            if (cached) {
              return threadStatusRow(slot, cached, false);
            }
            return threadStatusUnavailableRow(slot);
          }
        }));
        await telemetryPromise;
        for (const slot of seeds) {
          const seed = slot.seed;
          const loaded = loadedBySeed[seed];
          if (loaded) {
            threadProgressBySeed[seed] = loaded;
          }
        }
        tbody.innerHTML = rows.join("");
        renderThreadCursors(currentProgress);
      } finally {
        threadStatusBusy = false;
      }
    }

    function getApiBase() {
      return (document.getElementById("apiBase").value || "").trim().replace(/\/+$/, "");
    }

    function withApiBase(path) {
      const p = (path || "").trim();
      if (!p) return p;
      if (p.startsWith("http://") || p.startsWith("https://")) return p;
      const rel = p.startsWith("/") ? p : `/${p}`;
      const base = getApiBase();
      return base ? `${base}${rel}` : rel;
    }

    function fmtSec(v) {
      if (v === null || v === undefined) return "-";
      const s = Math.max(0, Math.floor(v));
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      if (h > 0) return `${h}h ${m}m ${ss}s`;
      if (m > 0) return `${m}m ${ss}s`;
      return `${ss}s`;
    }

    function toFiniteNumber(v, fallback = NaN) {
      const x = Number(v);
      return Number.isFinite(x) ? x : fallback;
    }

    function fmtSweepCounter(v) {
      if (!Number.isFinite(v)) return "-";
      const r = Math.round(v);
      return Math.abs(v - r) < 1e-6 ? `${r}` : v.toFixed(2);
    }

    function progressSeed(p) {
      return (String(p?.seed || "").trim() || "__default__");
    }

    function shouldApplyProgressUpdate(p, source = "unknown") {
      const sourceTag = String(source || "").toLowerCase();
      if (sourceTag === "poll" && usingStream && Date.now() - lastStreamAt <= streamStaleMs) {
        return false;
      }

      const seed = progressSeed(p);
      const tsMs = Date.parse(p?.timestamp_utc || "");
      const prev = progressOrderBySeed[seed];
      if (prev && Number.isFinite(tsMs) && Number.isFinite(prev.tsMs) && tsMs + 1 < prev.tsMs) {
        return false;
      }

      progressOrderBySeed[seed] = {
        tsMs: Number.isFinite(tsMs) ? tsMs : (prev?.tsMs ?? NaN),
      };
      return true;
    }

    function stabilizeInSweepFraction(p, phase, thermDone, rawFrac) {
      const seed = progressSeed(p);
      if (phase !== "thermalization" || !Number.isFinite(thermDone)) {
        delete thermSweepStateBySeed[seed];
        return Number.isFinite(rawFrac) ? clamp01(rawFrac) : 0.0;
      }

      const prev = thermSweepStateBySeed[seed];
      const sameSweep = Boolean(prev) && Math.abs(prev.thermDone - thermDone) < 1e-9;
      if (!Number.isFinite(rawFrac)) {
        if (sameSweep) return prev.inSweepFrac;
        thermSweepStateBySeed[seed] = { thermDone, inSweepFrac: 0.0 };
        return 0.0;
      }

      const frac = clamp01(rawFrac);
      if (!sameSweep) {
        thermSweepStateBySeed[seed] = { thermDone, inSweepFrac: frac };
        return frac;
      }
      const stable = Math.max(prev.inSweepFrac, frac);
      prev.inSweepFrac = stable;
      return stable;
    }

    function estimateThermState(p, elapsedSec) {
      const phase = String(p?.phase || "").toLowerCase();
      const ntherm = toFiniteNumber(p?.ntherm, NaN);
      const thermDone = toFiniteNumber(p?.therm_done, NaN);
      const subDone = toFiniteNumber(p?.therm_sweep_substep_done, NaN);
      const subTotal = toFiniteNumber(p?.therm_sweep_substep_total, NaN);
      const tsMs = Date.parse(p?.timestamp_utc || "");
      const elapsedVal = Number.isFinite(elapsedSec) ? elapsedSec : toFiniteNumber(p?.elapsed_sec, NaN);

      let thermLive = thermDone;
      let inSweepFrac = 0.0;
      let haveEstimate = false;

      if (
        phase === "thermalization" &&
        !p?.done &&
        Number.isFinite(ntherm) &&
        ntherm > 0 &&
        Number.isFinite(thermDone) &&
        thermDone >= 0 &&
        thermDone < ntherm &&
        Number.isFinite(subDone) &&
        Number.isFinite(subTotal) &&
        subTotal > 0
      ) {
        inSweepFrac = clamp01(subDone / subTotal);
        thermLive = Math.min(ntherm, thermDone + inSweepFrac);
        haveEstimate = true;
      } else if (
        phase === "thermalization" &&
        !p?.done &&
        Number.isFinite(ntherm) &&
        ntherm > 0 &&
        Number.isFinite(thermDone) &&
        thermDone > 0 &&
        thermDone < ntherm &&
        Number.isFinite(tsMs) &&
        Number.isFinite(elapsedVal)
      ) {
        const ageSec = Math.max(0, (Date.now() - tsMs) / 1000.0);
        const secPerSweep = elapsedVal / thermDone;
        if (Number.isFinite(secPerSweep) && secPerSweep > 0) {
          inSweepFrac = clamp01(Math.min(0.999, ageSec / secPerSweep));
          thermLive = Math.min(ntherm, thermDone + inSweepFrac);
          haveEstimate = true;
        }
      }

      if (phase === "thermalization" && !p?.done && Number.isFinite(thermDone)) {
        inSweepFrac = stabilizeInSweepFraction(
          p,
          phase,
          thermDone,
          haveEstimate ? inSweepFrac : NaN
        );
        if (Number.isFinite(ntherm) && ntherm > 0) {
          thermLive = Math.min(ntherm, thermDone + inSweepFrac);
        }
      } else {
        stabilizeInSweepFraction(p, phase, thermDone, NaN);
      }

      return { phase, ntherm, thermDone, thermLive, inSweepFrac, elapsedVal };
    }

    function avgTail(arr, n) {
      const m = Math.max(1, Math.min(arr.length, Math.floor(n)));
      const tail = arr.slice(arr.length - m);
      if (tail.length === 0) return 0.0;
      return tail.reduce((a, b) => a + b, 0) / tail.length;
    }

    function buildFluxDisplaySeries(ms, meta) {
      const mode = (document.getElementById("fluxDisplayMode").value || "stored").trim();
      const tailInput = toFiniteNumber(document.getElementById("fluxTailN").value, NaN);
      const defaultTail = toFiniteNumber(meta?.flux_vacuum_tail, 2);
      const tailN = Number.isFinite(tailInput) && tailInput > 0 ? Math.floor(tailInput) : Math.max(1, Math.floor(defaultTail));
      const hasRaw = ms.some(x => Array.isArray(x?.flux_profile_r_perp_raw));

      const series = ms.map((x) => {
        const stored = Array.isArray(x?.flux_profile_r_perp) ? x.flux_profile_r_perp : [];
        const raw = Array.isArray(x?.flux_profile_r_perp_raw) ? x.flux_profile_r_perp_raw : stored;

        if (mode === "raw") return raw;
        if (mode === "tail_subtracted") {
          if (raw.length === 0) return raw;
          const vac = avgTail(raw, tailN);
          return raw.map(v => v - vac);
        }
        return stored;
      });

      let note = "stored profile from file";
      if (mode === "raw") {
        note = hasRaw ? "raw profile from file" : "raw not present; using stored profile";
      } else if (mode === "tail_subtracted") {
        note = hasRaw
          ? `tail-subtracted from raw (N=${tailN})`
          : `tail-subtracted from stored (raw not present, N=${tailN})`;
      }
      return { series, mode, tailN, hasRaw, note };
    }

    function setPct(fillId, pct) {
      const el = document.getElementById(fillId);
      if (!el) return;
      el.style.width = `${Math.max(0, Math.min(100, pct))}%`;
    }

    function fmtList(v) {
      if (!Array.isArray(v)) return "-";
      return `[${v.join(", ")}]`;
    }

    function parseAFm(meta) {
      const inputEl = document.getElementById("aFmInput");
      const raw = (inputEl?.value || "").trim().replace(",", ".");
      const inputVal = Number(raw);
      const hasInput = raw.length > 0 && Number.isFinite(inputVal) && inputVal > 0;
      const inputIsDefault = hasInput && Math.abs(inputVal - defaultAFm) < 1e-9;

      const fromMeta = Number(meta?.a_fm ?? meta?.lattice_spacing_fm ?? 0);
      if (Number.isFinite(fromMeta) && fromMeta > 0) {
        // If user did not override a (or still uses dashboard default), trust run metadata.
        if (!hasInput || inputIsDefault) {
          if (inputEl) inputEl.value = String(fromMeta);
          return fromMeta;
        }
      }
      if (hasInput) return inputVal;
      if (Number.isFinite(fromMeta) && fromMeta > 0) return fromMeta;
      if (Number.isFinite(defaultAFm) && defaultAFm > 0) return defaultAFm;
      return null;
    }

    function inferLFromUIOrMeta(meta) {
      if (meta && Array.isArray(meta.L) && meta.L.length > 0) {
        return meta.L.map(x => Number(x)).filter(Number.isFinite);
      }
      const txt = (document.getElementById("paramL").textContent || "").trim();
      if (!txt.startsWith("[") || !txt.endsWith("]")) return [];
      const vals = txt.slice(1, -1).split(",").map(s => Number(s.trim())).filter(Number.isFinite);
      return vals;
    }

    function updatePhysicalScale(meta) {
      const aFm = parseAFm(meta);
      const L = inferLFromUIOrMeta(meta);
      if (!aFm || L.length === 0) {
        document.getElementById("paramAFm").textContent = "-";
        document.getElementById("paramAinvGeV").textContent = "-";
        document.getElementById("paramBoxFm").textContent = "-";
        return;
      }

      const aInvGeV = 0.1973269804 / aFm;
      document.getElementById("paramAFm").textContent = `${aFm.toFixed(6)}`;
      document.getElementById("paramAinvGeV").textContent = `${aInvGeV.toFixed(3)}`;

      if (L.length >= 4) {
        const lx = L[0] * aFm;
        const ly = L[1] * aFm;
        const lz = L[2] * aFm;
        const lt = L[3] * aFm;
        document.getElementById("paramBoxFm").textContent =
          `${lx.toFixed(2)} x ${ly.toFixed(2)} x ${lz.toFixed(2)} x ${lt.toFixed(2)} fm`;
      } else {
        const sizes = L.map(x => (x * aFm).toFixed(2));
        document.getElementById("paramBoxFm").textContent = `${sizes.join(" x ")} fm`;
      }
    }

    function clamp01(x) {
      if (!Number.isFinite(x)) return 0.5;
      return Math.max(0, Math.min(1, x));
    }

    function configStageSnapshot(p, meta) {
      const phase = String(p?.phase || "").toLowerCase();
      if (phase !== "production" || p?.done) return null;
      const measDone = toFiniteNumber(p?.meas_done, NaN);
      const nmeas = toFiniteNumber(p?.nmeas, NaN);
      if (!(Number.isFinite(measDone) && Number.isFinite(nmeas) && nmeas > 0)) return null;

      const measCfgIdx = toFiniteNumber(p?.meas_cfg_index, NaN);
      let cfgIdx = Number.isFinite(measCfgIdx)
        ? Math.max(1, Math.min(Math.round(measCfgIdx), Math.round(nmeas)))
        : Math.max(1, Math.min(Math.round(measDone) + 1, Math.round(nmeas)));

      const measSubDone = toFiniteNumber(p?.meas_cfg_substep_done, NaN);
      const measSubTotal = toFiniteNumber(p?.meas_cfg_substep_total, NaN);
      const measSubProgressRaw = toFiniteNumber(p?.meas_cfg_substep_progress, NaN);
      let measSubProgress = Number.isFinite(measSubProgressRaw)
        ? clamp01(measSubProgressRaw)
        : NaN;
      if (!Number.isFinite(measSubProgress) && Number.isFinite(measSubDone) && Number.isFinite(measSubTotal) && measSubTotal > 0) {
        measSubProgress = clamp01(measSubDone / measSubTotal);
      }

      const measStageRaw = typeof p?.meas_cfg_stage === "string" ? p.meas_cfg_stage : "";
      const measStage = measStageRaw ? measStageRaw.replace(/_/g, " ") : "starting";
      let stageProgress = Number.isFinite(measSubProgress) ? measSubProgress : 0;
      let measSubCount =
        Number.isFinite(measSubDone) && Number.isFinite(measSubTotal) && measSubTotal > 0
          ? `${Math.round(measSubDone)}/${Math.round(measSubTotal)}`
          : "-";

      // Worker emits a terminal sample for cfg N ("complete") before cfg N+1 begins.
      // For UI coherence, treat that as start of the next cfg unless this was final cfg.
      if (
        measStageRaw === "complete" &&
        Number.isFinite(measDone) &&
        Number.isFinite(nmeas) &&
        measDone < nmeas
      ) {
        cfgIdx = Math.max(1, Math.min(Math.round(measDone) + 1, Math.round(nmeas)));
        stageProgress = 0;
        measSubCount = "0/1";
      }

      if (measStageRaw === "skip_sweeps") {
        const shift = Array.isArray(p?.meas_cursor_shift)
          ? p.meas_cursor_shift.map((v) => toFiniteNumber(v, NaN))
          : [];
        const skipDoneByShift = shift.reduce((acc, v) => acc + (Number.isFinite(v) ? Math.max(0, v) : 0), 0);
        const skipSweepCount = toFiniteNumber(p?.meas_cursor_t, NaN);
        const ndGuess = Math.max(1, shift.length || inferLFromUIOrMeta(meta).length || 4);
        const skipTotal = Number.isFinite(skipSweepCount) && skipSweepCount > 0
          ? skipSweepCount * 2 * ndGuess
          : NaN;
        if (Number.isFinite(skipDoneByShift) && Number.isFinite(skipTotal) && skipTotal > 0) {
          // Keep progress tied to full-config substep progress when available.
          // The skip-specific ratio is only a fallback when global substep progress is missing.
          if (!Number.isFinite(measSubProgress)) {
            stageProgress = clamp01(skipDoneByShift / skipTotal);
          }
          measSubCount = `${Math.round(skipDoneByShift)}/${Math.round(skipTotal)}`;
        }
      }

      return {
        cfgIdx,
        stage: measStage,
        stageRaw: measStageRaw,
        progress: stageProgress,
        count: measSubCount,
      };
    }

    function renderCurrentConfigProgress(p, phase) {
      const pctEl = document.getElementById("cfgSubPct");
      if (!pctEl) return;
      const setThreadPart = (label, progress, cfgIdx) => {
        const pct = 100 * clamp01(toFiniteNumber(progress, 0));
        const cfg = Number.isFinite(cfgIdx) ? Math.max(1, Math.round(cfgIdx)) : NaN;
        setPct(`cfgSubFill${label}`, pct);
        const labelEl = document.getElementById(`cfgSubLabel${label}`);
        if (labelEl) {
          const cfgTxt = Number.isFinite(cfg) ? `cfg${cfg}` : "cfg-";
          labelEl.textContent = `${label} ${cfgTxt} ${pct.toFixed(1)}%`;
        }
      };
      const resetThreadParts = () => {
        for (const slot of threadSlots) {
          setThreadPart(slot.label, 0, NaN);
        }
      };

      const rootSeed = resolveThreadBaseSeed();
      const threads = threadSlots.map((slot) => {
        const seed = `${rootSeed}${slot.suffix}`;
        const tp = threadProgressBySeed[seed] || (p?.seed === seed ? p : null);
        const snapRaw = tp ? configStageSnapshot(tp, currentMeta) : null;
        const tsMs = Date.parse(tp?.timestamp_utc || "");
        const inProd = String(tp?.phase || "").toLowerCase() === "production" && !tp?.done;
        const liveProgress = snapRaw
          ? estimateLiveCfgProgress(seed, snapRaw.cfgIdx, snapRaw.progress, tsMs, inProd)
          : NaN;
        const snap = snapRaw
          ? {
              ...snapRaw,
              progress: stabilizeDisplayedCfgProgress(
                seed,
                snapRaw.cfgIdx,
                Number.isFinite(liveProgress) ? liveProgress : snapRaw.progress,
                inProd
              ),
            }
          : null;
        return snap ? { label: slot.label, snap } : null;
      }).filter(Boolean);

      if (threads.length > 0) {
        const byLabel = new Map(threads.map((t) => [t.label, t.snap]));
        for (const slot of threadSlots) {
          const snap = byLabel.get(slot.label) || null;
          setThreadPart(slot.label, snap?.progress, snap?.cfgIdx);
        }
        const avgProgress = clamp01(
          threads.reduce((acc, t) => acc + clamp01(toFiniteNumber(t?.snap?.progress, 0)), 0) / threads.length
        );
        const cfgIndices = threads
          .map((t) => Math.max(1, Math.round(toFiniteNumber(t?.snap?.cfgIdx, 1))))
          .filter(Number.isFinite);
        const minCfg = cfgIndices.length > 0 ? Math.min(...cfgIndices) : NaN;
        const maxCfg = cfgIndices.length > 0 ? Math.max(...cfgIndices) : NaN;
        const cfgSpan = Number.isFinite(minCfg) && Number.isFinite(maxCfg)
          ? (minCfg === maxCfg ? `cfg ${minCfg}` : `cfg ${minCfg}-${maxCfg}`)
          : "cfg -";
        pctEl.textContent = `${(100 * avgProgress).toFixed(1)}% (${cfgSpan} thread avg)`;
        return;
      }

      const singleRaw = configStageSnapshot(p, currentMeta);
      const singleLive = singleRaw
        ? estimateLiveCfgProgress(
            String(p?.seed || ""),
            singleRaw.cfgIdx,
            singleRaw.progress,
            Date.parse(p?.timestamp_utc || ""),
            String(p?.phase || "").toLowerCase() === "production" && !p?.done
          )
        : NaN;
      const single = singleRaw
        ? {
            ...singleRaw,
            progress: stabilizeDisplayedCfgProgress(
              String(p?.seed || ""),
              singleRaw.cfgIdx,
              Number.isFinite(singleLive) ? singleLive : singleRaw.progress,
              String(p?.phase || "").toLowerCase() === "production" && !p?.done
            ),
          }
        : null;
      if (single) {
        setThreadPart("A", single.progress, single.cfgIdx);
        for (const slot of threadSlots) {
          if (slot.label !== "A") setThreadPart(slot.label, 0, NaN);
        }
        pctEl.textContent = `${(100 * single.progress).toFixed(1)}% (cfg ${Math.max(1, Math.round(toFiniteNumber(single.cfgIdx, 1)))})`;
        return;
      }

      pctEl.textContent = phase === "production" ? "0.0%" : "-";
      resetThreadParts();
    }

    function normalizeLatticeCoord(v, l) {
      if (!Number.isFinite(v)) return NaN;
      if (!Number.isFinite(l) || l <= 0) return v;
      const span = Math.max(1, Math.round(l));
      const x = Math.round(v);
      return ((x % span) + span) % span;
    }

    function meanFinite(values) {
      const finite = (values || []).filter(Number.isFinite);
      if (finite.length === 0) return NaN;
      return finite.reduce((a, b) => a + b, 0) / finite.length;
    }

    function muProgressVector(coords, dims, cfgProgress, muCount = 4) {
      if (Number.isFinite(cfgProgress)) {
        // Keep per-mu cursors tightly coupled to true cfg progress.
        // This avoids large visual jumps when raw lattice shift telemetry changes axes.
        const base = clamp01(cfgProgress);
        const center = (muCount - 1) / 2;
        const spread = 0.06;
        const vals = Array.from({ length: muCount }, (_, mu) => {
          const offset = center > 0 ? ((mu - center) / center) : 0;
          return clamp01(base + spread * offset);
        });
        return rebalanceMuMean(vals, base);
      }

      const raw = Array.from({ length: muCount }, (_, mu) => {
        const c = toFiniteNumber(coords?.[mu], NaN);
        const l = toFiniteNumber(dims?.[mu], NaN);
        if (!Number.isFinite(c)) return NaN;
        const denom = Number.isFinite(l) && l > 1 ? (l - 1) : 1;
        return clamp01(c / denom);
      });
      const fallback = meanFinite(raw);
      const base = Number.isFinite(fallback) ? fallback : 0;
      return raw.map((v) => (Number.isFinite(v) ? v : base));
    }

    function rebalanceMuMean(values, targetMean) {
      const out = (values || []).map((v) => clamp01(toFiniteNumber(v, 0)));
      if (!Number.isFinite(targetMean) || out.length === 0) return out;
      const n = out.length;
      const target = clamp01(targetMean);
      for (let iter = 0; iter < 8; iter += 1) {
        const avg = meanFinite(out);
        if (!Number.isFinite(avg)) break;
        const err = target - avg;
        if (Math.abs(err) < 1e-6) break;
        const adjustable = [];
        for (let i = 0; i < n; i += 1) {
          if (err > 0 && out[i] < 1 - 1e-6) adjustable.push(i);
          if (err < 0 && out[i] > 1e-6) adjustable.push(i);
        }
        if (adjustable.length === 0) break;
        const step = (err * n) / adjustable.length;
        for (const i of adjustable) {
          out[i] = clamp01(out[i] + step);
        }
      }
      return out;
    }

    function stabilizeThreadMuProgress(key, targetMu, cfgIdx, cfgProgress, tsMs, inProduction, hasFreshData = true) {
      const cleanedTarget = (targetMu || []).map((v) => clamp01(toFiniteNumber(v, 0)));
      const prev = cursorMuStateByThread[key];
      const targetMean = Number.isFinite(cfgProgress) ? clamp01(cfgProgress) : meanFinite(cleanedTarget);
      const snapped = Number.isFinite(targetMean) ? rebalanceMuMean(cleanedTarget, targetMean) : cleanedTarget;
      // Hold last rendered point between telemetry samples; move only on fresh data.
      const out = (hasFreshData || !prev || !inProduction)
        ? snapped
        : (Array.isArray(prev.mu) && prev.mu.length > 0 ? prev.mu : snapped);
      const outMean = meanFinite(out);
      cursorMuStateByThread[key] = {
        cfgIdx,
        cfgProgress: Number.isFinite(cfgProgress) ? cfgProgress : toFiniteNumber(prev?.cfgProgress, NaN),
        tsMs: Number.isFinite(tsMs) ? tsMs : toFiniteNumber(prev?.tsMs, NaN),
        renderTsMs: Date.now(),
        meanProgress: Number.isFinite(outMean) ? outMean : toFiniteNumber(prev?.meanProgress, NaN),
        mu: out,
      };
      return out;
    }

    function cursorElementIds(label) {
      const suffix = String(label || "").trim().toUpperCase();
      return {
        key: suffix || "DEFAULT",
        canvasId: `cursorCanvas${suffix}`,
        infoId: `cursorInfo${suffix}`,
        kindId: `cursorKind${suffix}`,
        cfgId: `cursorCfg${suffix}`,
        backendId: `cursorBackend${suffix}`,
        cpuId: `cursorCpu${suffix}`,
        memId: `cursorMem${suffix}`,
        pauseBtnId: `threadPause${suffix}`,
        resumeBtnId: `threadResume${suffix}`,
        restartBtnId: `threadRestart${suffix}`,
        stagesId: `cursorStages${suffix}`,
        speedCanvasId: `speedCanvas${suffix}`,
        speedInfoId: `speedInfo${suffix}`,
      };
    }

    async function postThreadControl(action, opts = {}) {
      if (threadControlBusy) return { ok: false, error: "busy" };
      threadControlBusy = true;
      const token = (document.getElementById("authToken").value || "").trim();
      const payload = { action, ...opts, ...(token ? { token } : {}) };
      const url = withApiBase("/thread_control");
      try {
        const r = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...(token ? { "X-Auth-Token": token } : {}),
          },
          body: JSON.stringify(payload),
        });
        const out = await r.json().catch(() => ({}));
        if (!r.ok) {
          const msg = out?.error || `${r.status} ${r.statusText}`;
          throw new Error(msg);
        }
        return out;
      } finally {
        threadControlBusy = false;
      }
    }

    function setThreadActionButtonsDisabled(disabled = false) {
      const ids = [];
      for (const slot of threadSlots) {
        const suffix = String(slot?.label || "").toUpperCase();
        ids.push(`threadPause${suffix}`, `threadResume${suffix}`, `threadRestart${suffix}`);
      }
      ids.push("threadPauseAllBtn", "threadResumeAllBtn", "threadRestartAllBtn", "threadPipelineSelect");
      for (const id of ids) {
        const el = document.getElementById(id);
        if (el) el.disabled = Boolean(disabled);
      }
    }

    async function runThreadControl(action, opts = {}, statusPrefix = "thread control") {
      if (threadControlBusy) return;
      const chosenPipeline = (() => {
        const el = document.getElementById("threadPipelineSelect");
        const val = String(el?.value || "auto").trim().toLowerCase();
        return (val === "gpu" || val === "cpu") ? val : "auto";
      })();
      const controlOpts = ((action === "restart" || action === "restart_all") && !opts.pipeline)
        ? { ...opts, pipeline: chosenPipeline }
        : { ...opts };
      setThreadActionButtonsDisabled(true);
      const label = controlOpts.seed
        ? `${controlOpts.seed}`
        : (controlOpts.base_seed ? `${controlOpts.base_seed}{,-b,-c,-d}` : "");
      const pipelineTxt = (action === "restart" || action === "restart_all")
        ? ` pipeline=${controlOpts.pipeline || "auto"}`
        : "";
      setStreamStatus(`${statusPrefix}: ${action} ${label}${pipelineTxt}`.trim());
      try {
        const out = await postThreadControl(action, controlOpts);
        const msg = out?.message || `${action} ok`;
        setStreamStatus(`${statusPrefix}: ${msg}`);
        const root = baseSeed(controlOpts.seed || controlOpts.base_seed || resolveThreadBaseSeed());
        await refreshThreadTelemetry(root, true);
        renderThreadCursors(currentProgress);
        refreshThreadStatusTable(true);
      } catch (e) {
        setStreamStatus(`${statusPrefix}: ${action} failed (${e.message})`);
      } finally {
        setThreadActionButtonsDisabled(false);
      }
    }

    function canonicalThreadStage(stageRaw, kindRaw, doneFlag = false) {
      if (doneFlag) return "finalize";
      const stage = String(stageRaw || "").trim().toLowerCase();
      const kind = String(kindRaw || "").trim().toLowerCase();
      if (stage === "done" || stage === "complete") return "finalize";
      if (stage === "measure_polyakov") return "measure_loops";
      if (threadStageDefs.some((x) => x.key === stage)) return stage;
      if (stage === "measure_tdirs") {
        if (kind === "flux") return "measure_flux";
        if (kind === "loop") return "measure_loops";
        if (kind === "polyakov") return "measure_loops";
      }
      if (kind === "skip") return "skip_sweeps";
      if (kind === "loop") return "measure_loops";
      if (kind === "flux") return "measure_flux";
      if (kind === "polyakov") return "measure_loops";
      if (kind === "finalize") return "finalize";
      return "";
    }

    function buildThreadStagePipelineHtml(stageKey, stageRaw, cfgProgress, inProduction, doneFlag = false) {
      const activeIdx = threadStageActiveOrder.indexOf(stageKey);
      const cfgFrac = toFiniteNumber(cfgProgress, NaN);
      const isReady = String(stageRaw || "").toLowerCase() === "ready";
      const activeCount = Math.max(1, threadStageActiveOrder.length);

      return threadStageDefs.map((def) => {
        let cls = "pending";
        let fillPct = 0;
        const idx = threadStageActiveOrder.indexOf(def.key);
        if (doneFlag) {
          cls = "done";
          fillPct = 100;
        } else if (activeIdx >= 0 && idx < activeIdx) {
          cls = "done";
          fillPct = 100;
        } else if (activeIdx >= 0 && idx === activeIdx) {
          cls = "active";
          if (Number.isFinite(cfgFrac)) {
            fillPct = 100 * clamp01(cfgFrac * activeCount - idx);
          } else {
            fillPct = 18;
          }
        } else if (isReady && inProduction && idx === 0) {
          cls = "active";
          fillPct = 0;
        }

        const pctTxt = `${Math.max(0, Math.min(100, fillPct)).toFixed(1)}%`;
        return `<div class="stage-chip ${cls}" style="--stage-fill:${pctTxt};"><span>${escapeHtml(def.label)}</span></div>`;
      }).join("");
    }

    function renderThreadCursors(fallbackProgress = null) {
      const entries = threadCursorEntries(fallbackProgress);
      // Always accumulate per-thread speed history so graph mode is pre-populated.
      for (const entry of entries) {
        estimateThreadCfgSeconds(entry.seed, entry.progress, currentMeta);
      }
      applyThreadVizMode();
      const mode = getThreadVizMode();
      const speedYMax = mode === "speed" ? computeSpeedYAxisMax(entries) : NaN;
      if (mode === "speed") {
        drawAllThreadSpeedPanel(entries, speedYMax);
        return;
      }
      for (const entry of entries) {
        const ids = cursorElementIds(entry.slot.label);
        const target = {
          ...ids,
          label: entry.slot.label,
          seedHint: entry.seed,
          speedYMax,
        };
        drawMeasurementCursorPanel(entry.progress, currentMeta, target);
      }
    }

    function drawAllThreadSpeedPanel(entries, speedYMax) {
      const canvas = document.getElementById("speedCanvasAll");
      const infoEl = document.getElementById("speedInfoAll");
      if (!canvas || !infoEl) return;
      const colors = {
        A: "#52adff",
        B: "#2fd08a",
        C: "#f2c14b",
        D: "#f87171",
      };
      const lines = [];
      for (const entry of entries) {
        const label = String(entry?.slot?.label || "?");
        const seed = String(entry?.seed || "");
        const p = entry?.progress || null;
        const telemetry = threadTelemetryForSeed(seed, p);
        const secPerCfg = estimateThreadCfgSeconds(seed, p, currentMeta);
        const series = getThreadCurrentCfgSpeedSeries(seed);
        const points = Array.isArray(series.points)
          ? series.points.map((x) => ({ xSec: Number(x?.xSec), sec: Number(x?.sec) }))
            .filter((x) => Number.isFinite(x.xSec) && Number.isFinite(x.sec) && x.sec > 0)
          : [];
        const currentSec = Number.isFinite(series.currentSec) ? series.currentSec : secPerCfg;
        if (points.length === 0 && Number.isFinite(currentSec)) {
          points.push({ xSec: 0, sec: currentSec });
        }
        lines.push({
          label,
          seed,
          telemetry,
          color: colors[label] || "#9fb0cc",
          points,
          current: Number.isFinite(currentSec) ? currentSec : NaN,
          cfgIdx: Number.isFinite(series.cfgIdx) ? series.cfgIdx : NaN,
        });
      }

      const axisMax = Math.max(2, toFiniteNumber(speedYMax, 10));
      const lastBits = lines.map((line) => {
        const last = line.points.length > 0 ? line.points[line.points.length - 1] : null;
        return `${line.label}:cfg${Number.isFinite(line.cfgIdx) ? line.cfgIdx : "na"}:${line.points.length}:${last ? `${last.xSec.toFixed(1)}:${last.sec.toFixed(4)}` : "na"}:${Number.isFinite(line.current) ? line.current.toFixed(4) : "na"}`;
      }).join("|");
      const renderStateKey = "ALL";
      if (!speedRenderStateByThread[renderStateKey]) {
        speedRenderStateByThread[renderStateKey] = { lastSig: "", hasPainted: false };
      }
      const st = speedRenderStateByThread[renderStateKey];
      const sig = `${axisMax.toFixed(3)}|${lastBits}`;
      if (st.hasPainted && st.lastSig === sig) return;
      st.hasPainted = true;
      st.lastSig = sig;

      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      const allPoints = lines.flatMap((line) => line.points);
      if (allPoints.length < 1) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "12px sans-serif";
        ctx.fillText("Waiting for cursor-progress speed samples...", 14, 24);
        infoEl.textContent = lines.map((line) => `${line.label}: ${fmtCfgSeconds(line.current)}`).join(" | ");
        return;
      }

      const maxXSec = Math.max(1, ...allPoints.map((p) => Number(p?.xSec)));
      const padL = 44;
      const padR = 12;
      const padT = 28; // Reserve space for on-graph color legend.
      const padB = 18;
      const iw = Math.max(1, w - padL - padR);
      const ih = Math.max(1, h - padT - padB);
      const yFromV = (v) => {
        const clamped = Math.max(0, Math.min(axisMax, Number(v)));
        return padT + (1 - clamped / axisMax) * ih;
      };
      const xFromSec = (xSec) => {
        const clamped = Math.max(0, Math.min(maxXSec, Number(xSec)));
        return padL + (clamped / maxXSec) * iw;
      };

      ctx.strokeStyle = "#33405a";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT + ih);
      ctx.lineTo(w - padR, padT + ih);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + ih);
      ctx.stroke();

      for (const line of lines) {
        if (line.points.length === 0) continue;
        ctx.strokeStyle = line.color;
        ctx.fillStyle = line.color;
        ctx.lineWidth = 1.8;
        if (line.points.length > 1) {
          ctx.beginPath();
          line.points.forEach((p, i) => {
            const x = xFromSec(p.xSec);
            const y = yFromV(p.sec);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          });
          ctx.stroke();
        }
        const lp = line.points[line.points.length - 1];
        const lx = xFromSec(lp.xSec);
        const ly = yFromV(lp.sec);
        ctx.beginPath();
        ctx.arc(lx, ly, 3, 0, 2 * Math.PI);
        ctx.fill();
      }

      // Draw explicit color legend so each line is identifiable at a glance.
      ctx.font = "11px sans-serif";
      ctx.textBaseline = "middle";
      let legendX = padL + 2;
      const legendY = 12;
      for (const line of lines) {
        const legendLabel = `Thread ${line.label}`;
        ctx.strokeStyle = line.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 14, legendY);
        ctx.stroke();
        ctx.fillStyle = line.color;
        ctx.beginPath();
        ctx.arc(legendX + 7, legendY, 2.5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#cbd7ea";
        ctx.fillText(legendLabel, legendX + 20, legendY);
        legendX += 20 + ctx.measureText(legendLabel).width + 18;
      }

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "10px sans-serif";
      ctx.fillText(fmtCfgSeconds(axisMax), 4, padT + 8);
      ctx.fillText("0 s/cfg", 4, padT + ih);
      ctx.fillText("0s", padL, h - 4);
      ctx.fillText(`${Math.round(maxXSec)}s`, Math.max(padL, w - padR - 30), h - 4);

      const legendParts = lines.map((line) => {
        const cfg = Number.isFinite(line.cfgIdx) ? `cfg ${Math.round(line.cfgIdx)}` : "cfg -";
        const cpu = line.telemetry ? fmtThreadCpu(line.telemetry) : "-";
        const mem = line.telemetry ? fmtThreadMem(line.telemetry) : "-";
        return `${line.label} ${cfg} ${fmtCfgSeconds(line.current)} cpu=${cpu} mem=${mem}`;
      });
      infoEl.textContent = `${legendParts.join(" | ")} | x=[0, ${Math.round(maxXSec)}] s from config start | y=[0, ${Math.round(axisMax)}] s/cfg`;
    }

    function drawThreadSpeedPanel(p, target = {}) {
      const canvas = document.getElementById(target.speedCanvasId || "");
      const infoEl = document.getElementById(target.speedInfoId || "");
      if (!canvas || !infoEl) return;
      const label = String(target.label || "").trim();
      const renderStateKey = String(target.key || target.speedCanvasId || label || "DEFAULT");
      if (!speedRenderStateByThread[renderStateKey]) {
        speedRenderStateByThread[renderStateKey] = { lastSig: "", hasPainted: false };
      }
      const st = speedRenderStateByThread[renderStateKey];
      const seed = String(p?.seed || target.seedHint || "");
      const telemetry = threadTelemetryForSeed(seed, p);
      const secPerCfg = estimateThreadCfgSeconds(seed, p || null, currentMeta);
      const series = getThreadCurrentCfgSpeedSeries(seed);
      const points = Array.isArray(series.points)
        ? series.points.map((x) => ({ xSec: Number(x?.xSec), sec: Number(x?.sec) }))
          .filter((x) => Number.isFinite(x.xSec) && Number.isFinite(x.sec) && x.sec > 0)
        : [];
      const currentSec = Number.isFinite(series.currentSec) ? series.currentSec : secPerCfg;
      if (points.length === 0 && Number.isFinite(currentSec)) points.push({ xSec: 0, sec: currentSec });
      const sig = `${seed}|cfg${Number.isFinite(series.cfgIdx) ? Math.round(series.cfgIdx) : "na"}|${points.length}|${points.length > 0 ? `${points[points.length - 1].xSec.toFixed(1)}:${points[points.length - 1].sec.toFixed(6)}` : "na"}`;
      if (st.hasPainted && st.lastSig === sig) return;
      st.hasPainted = true;
      st.lastSig = sig;

      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      if (points.length < 1) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "12px sans-serif";
        ctx.fillText("Waiting for cursor-progress speed samples...", 14, 24);
        const cpuTxt = telemetry ? fmtThreadCpu(telemetry) : "-";
        const memTxt = telemetry ? fmtThreadMem(telemetry) : "-";
        infoEl.textContent = `speed: ${fmtCfgSeconds(currentSec)} | cpu=${cpuTxt} | mem=${memTxt} | samples=0`;
        return;
      }

      const axisMax = Math.max(2, toFiniteNumber(target.speedYMax, 10));
      const maxXSec = Math.max(1, ...points.map((x) => x.xSec));
      const padL = 40;
      const padR = 12;
      const padT = 10;
      const padB = 16;
      const iw = Math.max(1, w - padL - padR);
      const ih = Math.max(1, h - padT - padB);
      const yFromV = (v) => {
        const clamped = Math.max(0, Math.min(axisMax, Number(v)));
        return padT + (1 - clamped / axisMax) * ih;
      };
      const xFromSec = (xSec) => {
        const clamped = Math.max(0, Math.min(maxXSec, Number(xSec)));
        return padL + (clamped / maxXSec) * iw;
      };

      ctx.strokeStyle = "#33405a";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, padT + ih);
      ctx.lineTo(w - padR, padT + ih);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + ih);
      ctx.stroke();

      ctx.strokeStyle = "#52adff";
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      points.forEach((point, i) => {
        const x = xFromSec(point.xSec);
        const y = yFromV(point.sec);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      const last = points[points.length - 1];
      const lastX = xFromSec(last.xSec);
      const lastY = yFromV(last.sec);
      ctx.fillStyle = "#52adff";
      ctx.beginPath();
      ctx.arc(lastX, lastY, 3, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "10px sans-serif";
      ctx.fillText(fmtCfgSeconds(axisMax), 4, padT + 8);
      ctx.fillText("0 s/cfg", 4, padT + ih);
      const cpuTxt = telemetry ? fmtThreadCpu(telemetry) : "-";
      const memTxt = telemetry ? fmtThreadMem(telemetry) : "-";
      infoEl.textContent = `speed: ${fmtCfgSeconds(last.sec)} | cpu=${cpuTxt} | mem=${memTxt} | x=[0, ${Math.round(maxXSec)}] s from config start | y=[0, ${Math.round(axisMax)}] s/cfg | samples=${points.length}`;
    }

    function drawMeasurementCursorPanel(p, meta, target = {}) {
      const canvas = document.getElementById(target.canvasId || "");
      const infoEl = document.getElementById(target.infoId || "");
      const kindEl = document.getElementById(target.kindId || "");
      const cfgEl = document.getElementById(target.cfgId || "");
      const backendEl = document.getElementById(target.backendId || "");
      const cpuEl = document.getElementById(target.cpuId || "");
      const memEl = document.getElementById(target.memId || "");
      const pauseBtn = document.getElementById(target.pauseBtnId || "");
      const resumeBtn = document.getElementById(target.resumeBtnId || "");
      const restartBtn = document.getElementById(target.restartBtnId || "");
      const stagesEl = document.getElementById(target.stagesId || "");
      if (!canvas || !infoEl || !kindEl) return;
      const label = String(target.label || "").trim();
      const labelPrefix = label ? `${label}: ` : "";
      const renderStateKey = String(target.key || target.canvasId || label || "DEFAULT");
      if (!cursorRenderStateByThread[renderStateKey]) {
        cursorRenderStateByThread[renderStateKey] = { lastFreshKey: "", lastRenderSig: "", hasPainted: false };
      }
      const renderState = cursorRenderStateByThread[renderStateKey];
      const stageRaw = typeof p?.meas_cfg_stage === "string" ? p.meas_cfg_stage : "";
      const stageTxt = stageRaw ? stageRaw.replace(/_/g, " ") : "waiting";
      const phase = String(p?.phase || "").toLowerCase();
      const inProduction = phase === "production" && !p?.done;
      const kindRaw = typeof p?.meas_cursor_kind === "string" ? p.meas_cursor_kind : "";
      const kind = kindRaw.trim();
      const stageKey = canonicalThreadStage(stageRaw, kind, Boolean(p?.done));
      const tdir = toFiniteNumber(p?.meas_cursor_tdir, NaN);
      const sdir = toFiniteNumber(p?.meas_cursor_sdir, NaN);
      const rVal = toFiniteNumber(p?.meas_cursor_r, NaN);
      const tVal = toFiniteNumber(p?.meas_cursor_t, NaN);
      const rPerp = toFiniteNumber(p?.meas_cursor_r_perp, NaN);
      const shiftRaw = Array.isArray(p?.meas_cursor_shift) ? p.meas_cursor_shift : [];
      const shift = shiftRaw.map((v) => toFiniteNumber(v, NaN));
      const cfgSnap = configStageSnapshot(p, meta);
      const cfgProgress = cfgSnap && Number.isFinite(cfgSnap.progress) ? clamp01(cfgSnap.progress) : NaN;
      const cfgIdx = cfgSnap && Number.isFinite(cfgSnap.cfgIdx) ? Math.round(cfgSnap.cfgIdx) : NaN;
      const tsMs = Date.parse(p?.timestamp_utc || "");
      const seedForThread = String(target.seedHint || p?.seed || "");
      const cfgProgressLive = estimateLiveCfgProgress(seedForThread, cfgIdx, cfgProgress, tsMs, inProduction);
      const cfgProgressEffRaw = Number.isFinite(cfgProgressLive) ? cfgProgressLive : cfgProgress;
      const cfgProgressEff = stabilizeDisplayedCfgProgress(seedForThread, cfgIdx, cfgProgressEffRaw, inProduction);

      const dimsFromMeta = inferLFromUIOrMeta(meta);
      const inferredNd = Math.max(
        4,
        dimsFromMeta.length,
        shift.length,
        Number.isFinite(tdir) ? (Math.round(tdir) + 1) : 0,
        Number.isFinite(sdir) ? (Math.round(sdir) + 1) : 0
      );
      const dims = Array.from({ length: inferredNd }, (_, mu) => {
        const l = toFiniteNumber(dimsFromMeta[mu], NaN);
        return Number.isFinite(l) && l > 0 ? Math.round(l) : NaN;
      });
      const coords = Array(inferredNd).fill(NaN);

      for (let mu = 0; mu < Math.min(inferredNd, shift.length); mu += 1) {
        coords[mu] = normalizeLatticeCoord(shift[mu], dims[mu]);
      }
      if (kind === "loop") {
        // Use R/T only if shift data for those dirs is missing.
        if (Number.isFinite(tdir) && Number.isFinite(tVal) && tdir >= 0 && tdir < inferredNd) {
          const tmu = Math.round(tdir);
          if (!Number.isFinite(coords[tmu])) {
            coords[tmu] = normalizeLatticeCoord(tVal, dims[tmu]);
          }
        }
        if (Number.isFinite(sdir) && Number.isFinite(rVal) && sdir >= 0 && sdir < inferredNd) {
          const smu = Math.round(sdir);
          if (!Number.isFinite(coords[smu])) {
            coords[smu] = normalizeLatticeCoord(rVal, dims[smu]);
          }
        }
      }
      if (kind === "skip") {
        const hasShiftCoord = shift.some(Number.isFinite);
        if (!hasShiftCoord) {
          const skipDone = toFiniteNumber(rVal, NaN);
          const skipTotal = toFiniteNumber(tVal, NaN);
          if (Number.isFinite(skipDone) && Number.isFinite(skipTotal) && skipTotal > 0) {
            coords[0] = normalizeLatticeCoord(skipDone - 1, dims[0]);
          }
        }
      }
      const freshKey = [
        String(p?.timestamp_utc || ""),
        Number.isFinite(cfgIdx) ? Math.round(cfgIdx) : "na",
        Number.isFinite(cfgProgressEff) ? cfgProgressEff.toFixed(5) : "na",
        stageRaw || "-",
        kind || "-",
        Number.isFinite(toFiniteNumber(p?.meas_cfg_substep_done, NaN))
          ? Math.round(toFiniteNumber(p?.meas_cfg_substep_done, NaN))
          : "na",
        Number.isFinite(toFiniteNumber(p?.meas_cfg_substep_total, NaN))
          ? Math.round(toFiniteNumber(p?.meas_cfg_substep_total, NaN))
          : "na",
        shift.length > 0
          ? shift.map((v) => (Number.isFinite(v) ? Math.round(v) : "na")).join(",")
          : "-",
      ].join("|");
      const hasFreshData = freshKey !== renderState.lastFreshKey;
      if (hasFreshData) renderState.lastFreshKey = freshKey;
      const muCount = 4;
      const targetMuProgress = muProgressVector(coords, dims, cfgProgressEff, muCount);
      const muProgress = stabilizeThreadMuProgress(
        renderStateKey,
        targetMuProgress,
        cfgIdx,
        cfgProgressEff,
        tsMs,
        inProduction,
        hasFreshData
      );
      const muAvgProgress = meanFinite(muProgress);
      const telemetry = threadTelemetryForSeed(seedForThread, p);
      const pidNum = Math.round(toFiniteNumber(telemetry?.pid, NaN));
      const hasPid = Number.isFinite(pidNum) && pidNum > 0;
      const isPaused = Boolean(telemetry?.paused);
      const computeSummary = resolveComputeSummary(p, meta, telemetry);
      if (backendEl) {
        backendEl.textContent = `backend ${formatComputeSummary(computeSummary, { short: true })}`;
      }
      if (cpuEl) {
        cpuEl.textContent = `cpu ${telemetry ? fmtThreadCpu(telemetry) : "-"}`;
      }
      if (memEl) {
        memEl.textContent = `mem ${telemetry ? fmtThreadMem(telemetry) : "-"}`;
      }
      if (pauseBtn) {
        pauseBtn.dataset.seed = seedForThread;
        pauseBtn.disabled = !seedForThread || !hasPid || isPaused || threadControlBusy;
      }
      if (resumeBtn) {
        resumeBtn.dataset.seed = seedForThread;
        resumeBtn.disabled = !seedForThread || !hasPid || !isPaused || threadControlBusy;
      }
      if (restartBtn) {
        restartBtn.dataset.seed = seedForThread;
        restartBtn.disabled = !seedForThread || threadControlBusy;
      }
      const telemetrySig = [
        hasPid ? String(pidNum) : "na",
        isPaused ? "1" : "0",
        telemetry ? fmtThreadCpu(telemetry) : "-",
        telemetry ? fmtThreadMem(telemetry) : "-",
        formatComputeSummary(computeSummary, { short: true }),
      ].join(",");
      const renderSig = [
        phase,
        p?.done ? "1" : "0",
        stageRaw,
        kind || "-",
        Number.isFinite(cfgIdx) ? cfgIdx : "na",
        Number.isFinite(cfgProgressEff) ? cfgProgressEff.toFixed(4) : "na",
        muProgress.map((v) => (Number.isFinite(v) ? v.toFixed(4) : "na")).join(","),
        telemetrySig,
      ].join("|");
      if (renderState.hasPainted && renderState.lastRenderSig === renderSig) return;
      renderState.hasPainted = true;
      renderState.lastRenderSig = renderSig;

      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      const padL = 90;
      const padR = 24;
      const padT = 18;
      const padB = 24;
      const rows = muCount;
      const iw = Math.max(1, w - padL - padR);
      const ih = Math.max(1, h - padT - padB);
      const rowH = ih / Math.max(1, rows);

      if (!inProduction) {
        kindEl.textContent = `${labelPrefix}idle`;
        infoEl.textContent = "Cursor becomes active during production measurements.";
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        ctx.fillText("Idle (not in production phase)", 18, 28);
      } else {
        for (let mu = 0; mu < rows; mu += 1) {
          const y = padT + rowH * (mu + 0.5);
          const isT = Number.isFinite(tdir) && Math.round(tdir) === mu;
          const isS = Number.isFinite(sdir) && Math.round(sdir) === mu;
          const role = isT && isS ? "t/s" : (isT ? "t" : (isS ? "s" : ""));

          ctx.strokeStyle = "#33405a";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padL, y);
          ctx.lineTo(w - padR, y);
          ctx.stroke();

          const l = dims[mu];
          ctx.fillStyle = "#9fb0cc";
          ctx.font = "11px sans-serif";
          const baseLabel = Number.isFinite(l) ? `mu${mu} (L=${l})` : `mu${mu}`;
          ctx.fillText(role ? `${baseLabel} [${role}]` : baseLabel, 8, y + 4);

          const frac = muProgress[mu];
          if (Number.isFinite(frac)) {
            const x = padL + frac * iw;
            const markerColor = isT
              ? "#52adff"
              : (isS ? "#f2c14b" : "#2fd08a");
            ctx.strokeStyle = markerColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y - 8);
            ctx.lineTo(x, y + 8);
            ctx.stroke();
            ctx.fillStyle = markerColor;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
      }

      const trackY = h - 10;
      ctx.strokeStyle = "#33405a";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padL, trackY);
      ctx.lineTo(w - padR, trackY);
      ctx.stroke();
      const cfgDisplayProgress = Number.isFinite(cfgProgressEff) ? cfgProgressEff : muAvgProgress;
      if (Number.isFinite(cfgDisplayProgress)) {
        const px = padL + cfgDisplayProgress * iw;
        ctx.strokeStyle = "#ff5da2";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px, trackY - 7);
        ctx.lineTo(px, trackY + 7);
        ctx.stroke();
        ctx.fillStyle = "#ff5da2";
        ctx.beginPath();
        ctx.arc(px, trackY, 3.5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#cbd7ea";
        ctx.font = "11px sans-serif";
        ctx.fillText(`cfg ${(100 * cfgDisplayProgress).toFixed(1)}%`, padL, trackY - 7);
      } else {
        ctx.fillStyle = "#758aa6";
        ctx.font = "11px sans-serif";
        ctx.fillText("cfg -", padL, trackY - 7);
      }

      const details = [];
      if (telemetry) {
        const cpuTxt = fmtThreadCpu(telemetry);
        const memTxt = fmtThreadMem(telemetry);
        const pidTxt = fmtThreadPid(telemetry);
        details.push(`cpu=${cpuTxt}`);
        details.push(`mem=${memTxt}`);
        if (pidTxt) details.push(pidTxt);
        if (isPaused) details.push("paused");
      }
      if (Number.isFinite(cfgDisplayProgress)) details.push(`cfg=${(100 * cfgDisplayProgress).toFixed(1)}%`);
      details.push(`stage=${stageTxt}`);
      if (!inProduction) {
        details.push("idle");
      } else if (!kind) {
        details.push("cursor unavailable");
      } else if (kind === "loop") {
        details.push(`loop tdir=${Number.isFinite(tdir) ? Math.round(tdir) : "-"} sdir=${Number.isFinite(sdir) ? Math.round(sdir) : "-"} R=${Number.isFinite(rVal) ? Math.round(rVal) : "-"} T=${Number.isFinite(tVal) ? Math.round(tVal) : "-"}`);
      } else if (kind === "flux") {
        details.push(`flux tdir=${Number.isFinite(tdir) ? Math.round(tdir) : "-"} sdir=${Number.isFinite(sdir) ? Math.round(sdir) : "-"} R=${Number.isFinite(rVal) ? Math.round(rVal) : "-"} T=${Number.isFinite(tVal) ? Math.round(tVal) : "-"} r_perp=${Number.isFinite(rPerp) ? Math.round(rPerp) : "-"}`);
      } else if (kind === "polyakov") {
        details.push(`polyakov mu=${Number.isFinite(tdir) ? Math.round(tdir) : "-"}`);
      } else if (kind === "skip") {
        details.push(`skip ${Number.isFinite(rVal) ? Math.round(rVal) : "-"} / ${Number.isFinite(tVal) ? Math.round(tVal) : "-"}`);
      } else if (kind) {
        details.push(kind);
      }
      if (shift.length > 0 && shift.every(Number.isFinite)) {
        details.push(`shift=[${shift.map((v) => Math.round(v)).join(", ")}]`);
      }
      const cfgTotalRaw = toFiniteNumber(p?.meas_cfg_total, NaN);
      const cfgTotal = Number.isFinite(cfgTotalRaw) && cfgTotalRaw > 0 ? Math.round(cfgTotalRaw) : NaN;
      if (cfgEl) {
        if (Number.isFinite(cfgIdx)) {
          cfgEl.textContent = Number.isFinite(cfgTotal)
            ? `cfg ${cfgIdx}/${cfgTotal}`
            : `cfg ${cfgIdx}`;
        } else {
          cfgEl.textContent = (p?.done || phase === "complete" || phase === "done")
            ? "cfg done"
            : "cfg -";
        }
      }
      if (stagesEl) {
        stagesEl.innerHTML = buildThreadStagePipelineHtml(
          stageKey,
          stageRaw,
          cfgDisplayProgress,
          inProduction,
          Boolean(p?.done || phase === "complete" || phase === "done")
        );
      }
      kindEl.textContent = `${labelPrefix}${kind || stageTxt}`;
      infoEl.textContent = details.join(" | ");
    }

    function mixRgb(a, b, t) {
      const x = clamp01(t);
      return [
        Math.round(a[0] + (b[0] - a[0]) * x),
        Math.round(a[1] + (b[1] - a[1]) * x),
        Math.round(a[2] + (b[2] - a[2]) * x),
      ];
    }

    function runningMeanSem(values) {
      const mean = [];
      const low = [];
      const high = [];
      let n = 0;
      let mu = 0.0;
      let m2 = 0.0;
      for (const x of values) {
        n += 1;
        const d = x - mu;
        mu += d / n;
        const d2 = x - mu;
        m2 += d * d2;
        const sem = n > 1 ? Math.sqrt((m2 / (n - 1)) / n) : 0.0;
        mean.push(mu);
        low.push(mu - sem);
        high.push(mu + sem);
      }
      return { mean, low, high };
    }

    function pointwiseMeanSem(series) {
      const n = series.length;
      if (n === 0) return { mean: [], low: [], high: [] };
      const m = Math.max(...series.map(x => (Array.isArray(x) ? x.length : 0)));
      const mean = [];
      const low = [];
      const high = [];
      for (let j = 0; j < m; j += 1) {
        const vals = [];
        for (let i = 0; i < n; i += 1) {
          const row = series[i];
          if (Array.isArray(row) && typeof row[j] === "number" && Number.isFinite(row[j])) {
            vals.push(row[j]);
          }
        }
        if (vals.length === 0) {
          mean.push(0);
          low.push(0);
          high.push(0);
          continue;
        }
        const mu = vals.reduce((a, b) => a + b, 0) / vals.length;
        let varSample = 0.0;
        if (vals.length > 1) {
          for (const v of vals) varSample += (v - mu) * (v - mu);
          varSample /= (vals.length - 1);
        }
        const sem = vals.length > 1 ? Math.sqrt(varSample / vals.length) : 0.0;
        mean.push(mu);
        low.push(mu - sem);
        high.push(mu + sem);
      }
      return { mean, low, high };
    }

    function meanSem(values) {
      const vals = values.filter(v => typeof v === "number" && Number.isFinite(v));
      if (vals.length === 0) return null;
      const mean = vals.reduce((a, b) => a + b, 0) / vals.length;
      let varSample = 0.0;
      if (vals.length > 1) {
        for (const v of vals) varSample += (v - mean) * (v - mean);
        varSample /= (vals.length - 1);
      }
      const sem = vals.length > 1 ? Math.sqrt(varSample / vals.length) : 0.0;
      return { mean, sem, n: vals.length };
    }

    function isLegacyFilterEnabled() {
      return !!document.getElementById("legacyFilter").checked;
    }

    function drawXYError(canvasId, xs, ys, es, color = "#f38ba8", opts = {}) {
      const c = document.getElementById(canvasId);
      const ctx = c.getContext("2d");
      const w = c.width, h = c.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      const pts = [];
      for (let i = 0; i < xs.length; i += 1) {
        const x = Number(xs[i]);
        const y = Number(ys[i]);
        const e = Number(es[i] ?? 0);
        if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(e)) pts.push({ x, y, e });
      }
      const extraPts = Array.isArray(opts.extraPts)
        ? opts.extraPts
            .map((p) => ({ x: Number(p?.x), y: Number(p?.y), e: Number(p?.e ?? 0), label: String(p?.label || "") }))
            .filter((p) => Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.e))
        : [];
      if (pts.length < 2) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        if (extraPts.length >= 1) {
          ctx.fillText("Main V(R) sparse; showing provisional points", 18, 28);
        } else {
          ctx.fillText("Not enough V(R) points yet", 18, 28);
        }
        if (extraPts.length === 0) return;
      }
      if (pts.length === 0 && extraPts.length > 0) {
        // Use provisional points as the plotting anchor when no primary points are available.
        for (const p of extraPts) pts.push({ x: p.x, y: p.y, e: p.e });
      }
      if (pts.length < 1) {
        return;
      }

      const allPlotPts = [...pts, ...extraPts];
      const minX0 = Math.min(...allPlotPts.map(p => p.x));
      const maxX0 = Math.max(...allPlotPts.map(p => p.x));
      let minX = minX0, maxX = maxX0;
      if (minX === maxX) { minX -= 1; maxX += 1; }

      let minY = Math.min(...allPlotPts.map(p => p.y - p.e));
      let maxY = Math.max(...allPlotPts.map(p => p.y + p.e));
      if (minY === maxY) { minY -= 1e-9; maxY += 1e-9; }

      const padL = 40, padR = 24, padT = 20, padB = 34;
      const iw = w - padL - padR;
      const ih = h - padT - padB;

      const mapX = x => padL + ((x - minX) / (maxX - minX)) * iw;
      const mapY = y => padT + (1 - (y - minY) / (maxY - minY)) * ih;

      ctx.strokeStyle = "#34435f";
      ctx.lineWidth = 1;
      ctx.strokeRect(padL, padT, iw, ih);

      if (minY <= 0 && maxY >= 0) {
        const y0 = mapY(0);
        ctx.strokeStyle = "rgba(255, 208, 120, 0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padL, y0);
        ctx.lineTo(padL + iw, y0);
        ctx.stroke();
        ctx.fillStyle = "rgba(255, 208, 120, 0.95)";
        ctx.font = "11px sans-serif";
        ctx.fillText("0", padL + 4, y0 - 4);
      }

      const fitFn = typeof opts.fitFn === "function" ? opts.fitFn : null;
      if (fitFn) {
        const fitPts = [];
        const span = Math.max(1, 4 * pts.length);
        for (let i = 0; i <= span; i += 1) {
          const x = minX + (i / span) * (maxX - minX);
          const y = fitFn(x);
          if (Number.isFinite(y)) fitPts.push({ x, y });
        }
        if (fitPts.length >= 2) {
          ctx.strokeStyle = opts.fitColor || "rgba(82, 173, 255, 0.92)";
          ctx.lineWidth = Number.isFinite(Number(opts.fitWidth)) ? Number(opts.fitWidth) : 2;
          ctx.beginPath();
          fitPts.forEach((p, i) => {
            const x = mapX(p.x);
            const y = mapY(p.y);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          });
          ctx.stroke();
        }
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      pts.forEach((p, i) => {
        const x = mapX(p.x), y = mapY(p.y);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();

      ctx.strokeStyle = "rgba(243,139,168,0.85)";
      ctx.fillStyle = "#ffd6e4";
      pts.forEach(p => {
        const x = mapX(p.x), y = mapY(p.y);
        const y0 = mapY(p.y - p.e), y1 = mapY(p.y + p.e);
        ctx.beginPath();
        ctx.moveTo(x, y0);
        ctx.lineTo(x, y1);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
        ctx.fill();
      });

      if (extraPts.length > 0) {
        ctx.strokeStyle = "rgba(148,163,184,0.95)";
        ctx.fillStyle = "rgba(148,163,184,0.28)";
        ctx.setLineDash([4, 3]);
        for (const p of extraPts) {
          const x = mapX(p.x), y = mapY(p.y);
          const y0 = mapY(p.y - p.e), y1 = mapY(p.y + p.e);
          ctx.beginPath();
          ctx.moveTo(x, y0);
          ctx.lineTo(x, y1);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(x, y, 3.0, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "11px sans-serif";
      const xTicks = [...new Set(allPlotPts.map((p) => Number(p.x)).filter(Number.isFinite))].sort((a, b) => a - b);
      xTicks.forEach((xt) => {
        const x = mapX(xt);
        ctx.fillText(String(xt), x - 6, padT + ih + 14);
      });
      ctx.fillText(minY.toExponential(3), 6, h - 8);
      ctx.fillText(maxY.toExponential(3), 6, 16);
    }

    function drawXYLine(canvasId, xs, ys, opts = {}) {
      const c = document.getElementById(canvasId);
      const ctx = c.getContext("2d");
      const w = c.width, h = c.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      const pts = [];
      for (let i = 0; i < Math.min(xs.length, ys.length); i += 1) {
        const x = Number(xs[i]);
        const y = Number(ys[i]);
        if (Number.isFinite(x) && Number.isFinite(y)) pts.push({ x, y });
      }

      const emptyText = opts.emptyText || "Waiting for data";
      if (pts.length < 2) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        ctx.fillText(emptyText, 18, 28);
        return;
      }

      let minX = Number.isFinite(opts.minX) ? Number(opts.minX) : Math.min(...pts.map(p => p.x));
      let maxX = Number.isFinite(opts.maxX) ? Number(opts.maxX) : Math.max(...pts.map(p => p.x));
      let minY = Number.isFinite(opts.minY) ? Number(opts.minY) : Math.min(...pts.map(p => p.y));
      let maxY = Number.isFinite(opts.maxY) ? Number(opts.maxY) : Math.max(...pts.map(p => p.y));

      if (minX === maxX) { minX -= 1; maxX += 1; }
      if (minY === maxY) { minY -= 1e-9; maxY += 1e-9; }

      const padL = 54, padR = 24, padT = 20, padB = 34;
      const iw = w - padL - padR;
      const ih = h - padT - padB;

      const mapX = x => padL + ((x - minX) / (maxX - minX)) * iw;
      const mapY = y => padT + (1 - (y - minY) / (maxY - minY)) * ih;

      ctx.strokeStyle = "#34435f";
      ctx.lineWidth = 1;
      ctx.strokeRect(padL, padT, iw, ih);

      if (minY <= 0 && maxY >= 0) {
        const y0 = mapY(0);
        ctx.strokeStyle = "rgba(255, 208, 120, 0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padL, y0);
        ctx.lineTo(padL + iw, y0);
        ctx.stroke();
      }

      const baseColor = opts.color || "#f2c14b";
      const lineWidth = Number.isFinite(Number(opts.lineWidth)) ? Number(opts.lineWidth) : 2;
      const segColorFn = typeof opts.segmentColorFn === "function" ? opts.segmentColorFn : null;
      if (segColorFn && pts.length >= 2) {
        for (let i = 0; i < pts.length - 1; i += 1) {
          const p0 = pts[i];
          const p1 = pts[i + 1];
          const segColor = segColorFn(p0, p1, i, pts.length) || baseColor;
          ctx.strokeStyle = segColor;
          ctx.lineWidth = lineWidth;
          ctx.beginPath();
          ctx.moveTo(mapX(p0.x), mapY(p0.y));
          ctx.lineTo(mapX(p1.x), mapY(p1.y));
          ctx.stroke();
        }
      } else {
        ctx.strokeStyle = baseColor;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        pts.forEach((p, i) => {
          const x = mapX(p.x), y = mapY(p.y);
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "11px sans-serif";
      ctx.fillText(`${Math.round(minX)} s`, padL, h - 8);
      ctx.fillText(`${Math.round(maxX)} s`, Math.max(padL + 8, padL + iw - 36), h - 8);
      ctx.fillText(minY.toFixed(1), 6, h - 8);
      ctx.fillText(maxY.toFixed(1), 6, 16);
    }

    function legacyPairStats(ms, k0, k1, deltaT = 1) {
      const dt = Number(deltaT);
      if (!(Number.isFinite(dt) && dt > 0)) return null;
      const vals = [];
      for (const m of ms) {
        const a = m?.loops?.[k0]?.re;
        const b = m?.loops?.[k1]?.re;
        if (typeof a === "number" && typeof b === "number" && a > 0 && b > 0) {
          const v = -Math.log(b / a) / dt;
          if (Number.isFinite(v)) vals.push(v);
        }
      }
      return meanSem(vals);
    }

    function allSampleJackknifePairStats(ms, k0, k1, deltaT = 1) {
      const dt = Number(deltaT);
      if (!(Number.isFinite(dt) && dt > 0)) return null;
      const pairs = [];
      for (const m of ms) {
        const a = m?.loops?.[k0]?.re;
        const b = m?.loops?.[k1]?.re;
        if (typeof a === "number" && Number.isFinite(a) && typeof b === "number" && Number.isFinite(b)) {
          pairs.push([a, b]);
        }
      }
      const n = pairs.length;
      if (n < 2) return null;

      let sumA = 0;
      let sumB = 0;
      for (const [a, b] of pairs) {
        sumA += a;
        sumB += b;
      }
      const meanA = sumA / n;
      const meanB = sumB / n;
      if (!(meanA > 0 && meanB > 0)) return null;

      const central = -Math.log(meanB / meanA) / dt;
      if (!Number.isFinite(central)) return null;

      const jk = [];
      for (let i = 0; i < n; i += 1) {
        const a = (sumA - pairs[i][0]) / (n - 1);
        const b = (sumB - pairs[i][1]) / (n - 1);
        if (!(a > 0 && b > 0)) return null;
        const v = -Math.log(b / a) / dt;
        if (!Number.isFinite(v)) return null;
        jk.push(v);
      }
      const jkMean = jk.reduce((x, y) => x + y, 0) / jk.length;
      let varJk = 0.0;
      for (const v of jk) varJk += (v - jkMean) * (v - jkMean);
      const sem = Math.sqrt(((n - 1) / n) * varJk);
      return { mean: central, sem, n };
    }

    function allSampleRatioJackknifePairStats(ms, k0, k1, deltaT = 1) {
      const dt = Number(deltaT);
      if (!(Number.isFinite(dt) && dt > 0)) return null;
      const epsDen = 1e-30;
      const pairs = [];
      for (const m of ms) {
        const a = m?.loops?.[k0]?.re;
        const b = m?.loops?.[k1]?.re;
        if (typeof a === "number" && Number.isFinite(a) && typeof b === "number" && Number.isFinite(b)) {
          pairs.push([a, b]);
        }
      }
      const n = pairs.length;
      if (n < 2) return null;

      let sumA = 0;
      let sumB = 0;
      for (const [a, b] of pairs) {
        sumA += a;
        sumB += b;
      }
      const meanA = sumA / n;
      const meanB = sumB / n;
      if (!Number.isFinite(meanA) || !Number.isFinite(meanB) || Math.abs(meanA) <= epsDen || Math.abs(meanB) <= epsDen) return null;
      const ratio = meanB / meanA;
      if (!(ratio > 0)) return null;

      const central = -Math.log(ratio) / dt;
      if (!Number.isFinite(central)) return null;

      const jk = [];
      let jkStable = true;
      for (let i = 0; i < n; i += 1) {
        const a = (sumA - pairs[i][0]) / (n - 1);
        const b = (sumB - pairs[i][1]) / (n - 1);
        if (!Number.isFinite(a) || !Number.isFinite(b) || Math.abs(a) <= epsDen) {
          jkStable = false;
          break;
        }
        const r = b / a;
        if (!(r > 0)) {
          jkStable = false;
          break;
        }
        const v = -Math.log(r) / dt;
        if (!Number.isFinite(v)) {
          jkStable = false;
          break;
        }
        jk.push(v);
      }
      if (jkStable && jk.length === n) {
        const jkMean = jk.reduce((x, y) => x + y, 0) / jk.length;
        let varJk = 0.0;
        for (const v of jk) varJk += (v - jkMean) * (v - jkMean);
        const sem = Math.sqrt(((n - 1) / n) * varJk);
        return { mean: central, sem, n, meanA, meanB, ratio, semMethod: "jackknife" };
      }

      // Delta-method fallback when leave-one-out sign flips make jackknife undefined.
      let sAA = 0.0;
      let sBB = 0.0;
      let sAB = 0.0;
      for (const [a, b] of pairs) {
        const da = a - meanA;
        const db = b - meanB;
        sAA += da * da;
        sBB += db * db;
        sAB += da * db;
      }
      const varA = n > 1 ? sAA / (n * (n - 1)) : NaN;
      const varB = n > 1 ? sBB / (n * (n - 1)) : NaN;
      const covAB = n > 1 ? sAB / (n * (n - 1)) : NaN;
      if (!(Number.isFinite(varA) && Number.isFinite(varB) && Number.isFinite(covAB))) return null;
      const invA = 1.0 / meanA;
      const invB = 1.0 / meanB;
      const varV = (invA * invA * varA + invB * invB * varB - 2.0 * invA * invB * covAB) / (dt * dt);
      const sem = Math.sqrt(Math.max(0.0, varV));
      return { mean: central, sem, n, meanA, meanB, ratio, semMethod: "delta" };
    }

    function choosePlateauCandidate(candidates) {
      if (!Array.isArray(candidates) || candidates.length === 0) return null;
      const cands = [...candidates].sort((a, b) => a.t0 - b.t0);

      // Prefer the latest adjacent-T effective mass that is statistically compatible
      // with the immediately earlier one (simple plateau consistency test).
      for (let i = cands.length - 1; i >= 1; i -= 1) {
        const cur = cands[i];
        const prev = cands[i - 1];
        const sCur = Number(cur.sem);
        const sPrev = Number(prev.sem);
        const scale = Math.sqrt(
          Math.max(0, (Number.isFinite(sCur) ? sCur * sCur : 0) + (Number.isFinite(sPrev) ? sPrev * sPrev : 0))
        );
        if (!(Number.isFinite(scale) && scale > 0)) continue;
        if (Math.abs(cur.mean - prev.mean) <= 2.0 * scale) {
          return { ...cur, plateauRef: `stable vs T${prev.t0}->T${prev.t1}` };
        }
      }

      // Fallback: smallest uncertainty, and for ties prefer larger T.
      let best = cands[0];
      for (const c of cands.slice(1)) {
        const eBest = Number.isFinite(best.sem) && best.sem > 0 ? best.sem : Infinity;
        const eCur = Number.isFinite(c.sem) && c.sem > 0 ? c.sem : Infinity;
        if (eCur < eBest - 1e-15 || (Math.abs(eCur - eBest) <= 1e-15 && c.t0 > best.t0)) {
          best = c;
        }
      }
      return { ...best, plateauRef: "fallback min-err" };
    }

    function fitPotentialFromLoopMeansInT(ms, R, Ts) {
      // Primary estimator: fit a constant plateau to adjacent-T effective masses
      // V_eff(R,T) = -ln[W(R,T+1)/W(R,T)] over contiguous late-T windows.
      const adj = [];
      for (let i = 0; i + 1 < Ts.length; i += 1) {
        const t0 = Ts[i];
        const t1 = Ts[i + 1];
        const k0 = `R${R}_T${t0}`;
        const k1 = `R${R}_T${t1}`;
        const st = allSampleRatioJackknifePairStats(ms, k0, k1, t1 - t0);
        if (!st) continue;
        const mean = Number(st.mean);
        const sem = Number(st.sem);
        if (!(Number.isFinite(mean) && Number.isFinite(sem) && sem > 0)) continue;
        adj.push({
          t0,
          t1,
          mean,
          sem,
          n: Number(st.n) || 0,
          z: Math.abs(mean) / sem,
          sign: mean > 0 ? 1 : (mean < 0 ? -1 : 0),
        });
      }
      adj.sort((a, b) => a.t0 - b.t0);

      if (adj.length >= 2) {
        const windows = [];
        const minWindowPoints = adj.length >= 3 ? 3 : 2;
        for (let start = 0; start < adj.length; start += 1) {
          const subset = adj.slice(start);
          if (subset.length < minWindowPoints) continue;
          const fit = buildWeightedConstant(
            subset.map((p) => p.mean),
            subset.map((p) => p.sem)
          );
          if (!fit) continue;
          const chi2dof = fit.dof > 0 ? (fit.chi2 / fit.dof) : NaN;
          windows.push({
            subset,
            fit,
            chi2dof,
            sem: Number.isFinite(fit.errA0) ? fit.errA0 : NaN,
          });
        }

        const stable = windows.filter((w) => Number.isFinite(w.chi2dof) && w.chi2dof <= 2.5);
        let chosen = null;
        if (stable.length > 0) {
          stable.sort((a, b) => {
            const aStart = Number(a.subset?.[0]?.t0);
            const bStart = Number(b.subset?.[0]?.t0);
            if (Number.isFinite(aStart) && Number.isFinite(bStart) && aStart !== bStart) return bStart - aStart;
            const aSem = Number.isFinite(a.sem) ? a.sem : Number.POSITIVE_INFINITY;
            const bSem = Number.isFinite(b.sem) ? b.sem : Number.POSITIVE_INFINITY;
            if (aSem !== bSem) return aSem - bSem;
            const aChi = Number.isFinite(a.chi2dof) ? a.chi2dof : Number.POSITIVE_INFINITY;
            const bChi = Number.isFinite(b.chi2dof) ? b.chi2dof : Number.POSITIVE_INFINITY;
            return aChi - bChi;
          });
          chosen = stable[0];
        } else if (windows.length > 0) {
          // If no suffix looks stable yet, use all available adjacent pairs
          // to avoid cherry-picking while statistics are still limited.
          chosen = windows[0];
        }

        if (chosen) {
          const subset = chosen.subset;
          const signs = subset.map((p) => p.sign).filter((s) => s !== 0);
          const signSet = new Set(signs);
          const signMode = signSet.size === 1
            ? (signs[0] > 0 ? "positive" : "negative")
            : "mixed";
          let signChanges = 0;
          for (let i = 1; i < signs.length; i += 1) {
            if (signs[i] !== signs[i - 1]) signChanges += 1;
          }
          const nSamples = subset.reduce((acc, p) => Math.min(acc, Number(p.n) || 0), Number.POSITIVE_INFINITY);
          const tValues = [];
          for (const p of subset) {
            if (tValues.length === 0 || tValues[tValues.length - 1] !== p.t0) tValues.push(p.t0);
            if (tValues[tValues.length - 1] !== p.t1) tValues.push(p.t1);
          }
          const tMin = Number(subset[0]?.t0);
          const tMax = Number(subset[subset.length - 1]?.t1);
          const methodTag = stable.length > 0 ? "late-T stable suffix" : "all-pair fallback";
          return {
            mean: chosen.fit.A0,
            sem: chosen.sem,
            n: Number.isFinite(nSamples) ? nSamples : 0,
            sign: signMode === "positive" ? 1 : (signMode === "negative" ? -1 : 0),
            signMode,
            signChanges,
            tValues,
            fitPoints: chosen.fit.n,
            chi2: chosen.fit.chi2,
            dof: chosen.fit.dof,
            chi2dof: chosen.fit.dof > 0 ? (chosen.fit.chi2 / chosen.fit.dof) : NaN,
            avgZ: subset.reduce((a, p) => a + (Number.isFinite(p.z) ? p.z : 0), 0) / Math.max(1, subset.length),
            method: "t_plateau_fit",
            t0: tMin,
            t1: tMax,
            plateauRef:
              `fit Veff(R,T)=const using ${subset.length}/${adj.length} adjacent pairs (${methodTag})` +
              `, T=${tMin}->${tMax}`,
          };
        }
      }

      // Fallback estimator: jackknife slope fit of ln W(R,T) vs T.
      // Only include contiguous T-points from Tmin with positive mean,
      // z >= 1.5, and monotonically decreasing <W> (noise filter).
      const zMin = 1.5;
      const allRows = [];
      for (const T of Ts) {
        const key = `R${R}_T${T}`;
        const vals = [];
        for (const m of ms) {
          const x = m?.loops?.[key]?.re;
          if (typeof x === "number" && Number.isFinite(x)) vals.push(x);
        }
        const st = meanSem(vals);
        if (!st) continue;
        const absMean = Math.abs(st.mean);
        if (!(Number.isFinite(absMean) && absMean > 1e-30)) continue;
        const sign = st.mean > 0 ? 1 : (st.mean < 0 ? -1 : 0);
        if (sign === 0) continue;
        const z = Number.isFinite(st.sem) && st.sem > 0 ? (absMean / st.sem) : Infinity;
        allRows.push({ T, mean: st.mean, sem: st.sem, n: st.n, absMean, sign, z, key });
      }
      allRows.sort((a, b) => a.T - b.T);

      // Select contiguous T-points: positive, z >= zMin, monotonically decreasing.
      const rows = [];
      for (const row of allRows) {
        if (row.sign < 0) break;
        if (row.z < zMin) break;
        if (rows.length > 0 && row.mean >= rows[rows.length - 1].mean) break;
        rows.push(row);
      }
      // Relaxed fallback if strict gives < 2 points.
      if (rows.length < 2) {
        rows.length = 0;
        let lastMean = Infinity;
        for (const row of allRows) {
          if (row.sign > 0 && row.z >= 1.0 && row.mean < lastMean) {
            rows.push(row);
            lastMean = row.mean;
          }
        }
      }
      if (rows.length < 2) return null;

      // Jackknife the ln W(R,T) slope fit for proper error propagation.
      const n = ms.length;
      const TArr = rows.map((p) => p.T);
      const keys = rows.map((p) => p.key);

      // Collect per-config values for the selected T-points.
      const configVals = []; // configVals[i][j] = W(R,T_j) for config i
      for (let i = 0; i < n; i += 1) {
        const row = [];
        for (const key of keys) {
          const v = ms[i]?.loops?.[key]?.re;
          row.push(typeof v === "number" && Number.isFinite(v) ? v : 0);
        }
        configVals.push(row);
      }

      // Central fit: means → log → weighted linear.
      const centralMeans = TArr.map((_, j) => {
        let s = 0; for (let i = 0; i < n; i += 1) s += configVals[i][j];
        return s / n;
      });
      if (centralMeans.some((m) => m <= 0)) return null;
      const centralY = centralMeans.map(Math.log);
      const centralEs = centralMeans.map((m, j) => Math.max(1e-6, rows[j].sem / m));
      const centralFit = buildWeightedLinear2(TArr, centralY, centralEs);
      if (!centralFit) return null;
      const V_central = -centralFit.A1;

      // Jackknife: leave-one-out fits.
      const V_jk = [];
      for (let leave = 0; leave < n; leave += 1) {
        const jkMeans = TArr.map((_, j) => {
          let s = 0;
          for (let i = 0; i < n; i += 1) { if (i !== leave) s += configVals[i][j]; }
          return s / (n - 1);
        });
        if (jkMeans.some((m) => m <= 0)) continue;
        const jkY = jkMeans.map(Math.log);
        const jkFit = buildWeightedLinear2(TArr, jkY, centralEs);
        if (jkFit) V_jk.push(-jkFit.A1);
      }

      let V, errV;
      if (V_jk.length >= Math.floor(n * 0.9)) {
        // Use jackknife error.
        const nj = V_jk.length;
        const jkMean = V_jk.reduce((a, b) => a + b, 0) / nj;
        const jkVar = V_jk.reduce((a, v) => a + (v - jkMean) * (v - jkMean), 0);
        V = V_central;
        errV = Math.sqrt(((nj - 1) / nj) * jkVar);
      } else {
        // Jackknife unstable, fall back to analytic error.
        V = V_central;
        errV = Number.isFinite(centralFit.errA1) ? centralFit.errA1 : NaN;
      }
      if (!(Number.isFinite(V) && Number.isFinite(errV) && errV > 0)) return null;

      const signSet = new Set(rows.map((p) => p.sign));
      const signMode = signSet.size === 1
        ? (rows[0].sign > 0 ? "positive" : "negative")
        : "mixed";
      let signChanges = 0;
      for (let i = 1; i < rows.length; i += 1) {
        if (rows[i].sign !== rows[i - 1].sign) signChanges += 1;
      }
      const nSamples = rows.reduce((acc, p) => Math.min(acc, Number(p.n) || 0), Number.POSITIVE_INFINITY);
      const tValues = rows.map((p) => p.T);
      const tMin = tValues.length > 0 ? Math.min(...tValues) : NaN;
      const tMax = tValues.length > 0 ? Math.max(...tValues) : NaN;
      const droppedT = allRows.filter((r) => !rows.includes(r)).map((r) => r.T);
      const jkTag = V_jk.length >= Math.floor(n * 0.9) ? "jackknife" : "analytic";
      return {
        mean: V,
        sem: errV,
        n: Number.isFinite(nSamples) ? nSamples : 0,
        sign: signMode === "positive" ? 1 : (signMode === "negative" ? -1 : 0),
        signMode,
        signChanges,
        tValues,
        fitPoints: rows.length,
        chi2: centralFit.chi2,
        dof: centralFit.dof,
        chi2dof: centralFit.dof > 0 ? (centralFit.chi2 / centralFit.dof) : NaN,
        avgZ: rows.reduce((a, p) => a + (Number.isFinite(p.z) ? p.z : 0), 0) / Math.max(1, rows.length),
        method: "t_fit",
        t0: tMin,
        t1: tMax,
        plateauRef: `fallback ${jkTag} fit ln W vs T, ${rows.length}/${allRows.length} T-pts (z>=${zMin})` +
          (droppedT.length > 0 ? ` dropped T=${droppedT.join(",")}` : ""),
      };
    }

    function effectiveTFitSem(tFit) {
      const baseSem = Number(tFit?.sem);
      if (!(Number.isFinite(baseSem) && baseSem > 0)) {
        return { semEff: NaN, inflation: NaN, notes: [] };
      }
      let semEff = baseSem;
      const notes = [];

      const chi2dof = Number(tFit?.chi2dof);
      if (Number.isFinite(chi2dof) && chi2dof > 1.0) {
        const factor = Math.sqrt(Math.min(16.0, chi2dof));
        semEff *= factor;
        notes.push(`chi2x${factor.toFixed(2)}`);
      }

      const signMode = String(tFit?.signMode || "");
      const signFlips = Number(tFit?.signChanges);
      if (signMode === "mixed") {
        const factor = 1.0 + 0.35 * Math.min(6, Number.isFinite(signFlips) ? signFlips : 1);
        semEff *= factor;
        notes.push(`mixed-signx${factor.toFixed(2)}`);
      }

      const avgZ = Number(tFit?.avgZ);
      if (Number.isFinite(avgZ) && avgZ > 0 && avgZ < 1.0) {
        const factor = 1.0 + (1.0 - avgZ);
        semEff *= factor;
        notes.push(`low-snrx${factor.toFixed(2)}`);
      }

      const inflation = semEff / baseSem;
      return {
        semEff,
        inflation: Number.isFinite(inflation) ? inflation : NaN,
        notes,
      };
    }

    function allSampleSignCoherentPairStats(ms, k0, k1, deltaT = 1) {
      return allSampleRatioJackknifePairStats(ms, k0, k1, deltaT);
    }

    function computePotentialSupplemental(ms, meta, pot) {
      const Rs = Array.isArray(meta?.R) ? meta.R.map(Number).filter(Number.isFinite) : [];
      const Ts = Array.isArray(meta?.T) ? meta.T.map(Number).filter(Number.isFinite).sort((a, b) => a - b) : [];
      if (Rs.length === 0 || Ts.length < 2 || !pot) return { extra: [], excluded: [] };
      const covered = new Set();
      for (let i = 0; i < pot.Rs.length; i += 1) {
        const r = pot.Rs[i];
        const y = pot.means[i];
        const e = pot.sems[i];
        if (Number.isFinite(r) && Number.isFinite(y) && Number.isFinite(e)) covered.add(Number(r));
      }
      const pairs = [];
      for (let i = 0; i < Ts.length; i += 1) {
        for (let j = i + 1; j < Ts.length; j += 1) {
          pairs.push([Ts[i], Ts[j]]);
        }
      }

      const extra = [];
      const excluded = [];
      for (const R of Rs) {
        if (covered.has(Number(R))) continue;
        let best = null;
        for (const [t0, t1] of pairs) {
          const k0 = `R${R}_T${t0}`;
          const k1 = `R${R}_T${t1}`;
          const st = allSampleSignCoherentPairStats(ms, k0, k1, t1 - t0);
          if (!st) continue;
          if (!best || st.n > best.n || (st.n === best.n && t1 > best.t1)) {
            best = { R, t0, t1, mean: st.mean, sem: st.sem, n: st.n };
          }
        }
        if (best) {
          extra.push(best);
        } else {
          const adjPairs = [];
          for (let i = 0; i + 1 < Ts.length; i += 1) adjPairs.push([Ts[i], Ts[i + 1]]);
          let haveSamples = false;
          let haveSignCoherent = false;
          let haveEstimator = false;
          let example = "";
          for (const [t0, t1] of adjPairs) {
            const k0 = `R${R}_T${t0}`;
            const k1 = `R${R}_T${t1}`;
            const ab = [];
            for (const m of ms) {
              const a = m?.loops?.[k0]?.re;
              const b = m?.loops?.[k1]?.re;
              if (typeof a === "number" && Number.isFinite(a) && typeof b === "number" && Number.isFinite(b)) {
                ab.push([a, b]);
              }
            }
            if (ab.length < 2) continue;
            haveSamples = true;

            let sumA = 0.0;
            let sumB = 0.0;
            for (const [a, b] of ab) {
              sumA += a;
              sumB += b;
            }
            const meanA = sumA / ab.length;
            const meanB = sumB / ab.length;
            if (!Number.isFinite(meanA) || !Number.isFinite(meanB) || Math.abs(meanA) <= 1e-30) continue;
            const ratio = meanB / meanA;
            if (!(ratio > 0)) {
              if (!example) {
                example = `example T${t0}->T${t1}: ⟨W${t0}⟩=${meanA.toExponential(2)}, ⟨W${t1}⟩=${meanB.toExponential(2)}`;
              }
              continue;
            }
            haveSignCoherent = true;
            const st = allSampleSignCoherentPairStats(ms, k0, k1, t1 - t0);
            if (st) {
              haveEstimator = true;
              break;
            }
          }
          if (!haveSamples) {
            excluded.push({ R, reason: "insufficient samples across adjacent T pairs" });
          } else if (!haveSignCoherent) {
            excluded.push({ R, reason: `no same-sign adjacent ratio (${example || "ensemble mean-loop ratio <= 0"})` });
          } else if (!haveEstimator) {
            excluded.push({ R, reason: "adjacent sign-coherent ratios exist but error estimate is ill-conditioned" });
          } else {
            excluded.push({ R, reason: "excluded by plateau selector" });
          }
        }
      }
      return { extra, excluded };
    }

    function solveLinear2(mat, vec) {
      if (!Array.isArray(mat) || mat.length !== 2 || !Array.isArray(vec) || vec.length !== 2) return null;
      const a = Number(mat[0]?.[0]);
      const b = Number(mat[0]?.[1]);
      const c = Number(mat[1]?.[0]);
      const d = Number(mat[1]?.[1]);
      const y0 = Number(vec[0]);
      const y1 = Number(vec[1]);
      if (!(Number.isFinite(a) && Number.isFinite(b) && Number.isFinite(c) && Number.isFinite(d))) return null;
      if (!(Number.isFinite(y0) && Number.isFinite(y1))) return null;
      const det = a * d - b * c;
      if (!(Math.abs(det) > 1e-14)) return null;
      const inv = 1.0 / det;
      return [
        (d * y0 - b * y1) * inv,
        (-c * y0 + a * y1) * inv,
      ];
    }

    function invert2(mat) {
      if (!Array.isArray(mat) || mat.length !== 2) return null;
      const a = Number(mat[0]?.[0]);
      const b = Number(mat[0]?.[1]);
      const c = Number(mat[1]?.[0]);
      const d = Number(mat[1]?.[1]);
      if (!(Number.isFinite(a) && Number.isFinite(b) && Number.isFinite(c) && Number.isFinite(d))) return null;
      const det = a * d - b * c;
      if (!(Math.abs(det) > 1e-14)) return null;
      const inv = 1.0 / det;
      return [
        [d * inv, -b * inv],
        [-c * inv, a * inv],
      ];
    }

    function buildWeightedLinear2(xVals, yVals, errVals) {
      if (!Array.isArray(xVals) || !Array.isArray(yVals) || xVals.length !== yVals.length || xVals.length < 2) return null;
      const M = [
        [0, 0],
        [0, 0],
      ];
      const b = [0, 0];
      let n = 0;
      for (let i = 0; i < xVals.length; i += 1) {
        const x = Number(xVals[i]);
        const y = Number(yVals[i]);
        const e = Number(errVals?.[i]);
        if (!(Number.isFinite(x) && Number.isFinite(y))) continue;
        const sem = Number.isFinite(e) && e > 0 ? e : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        n += 1;
        M[0][0] += w;
        M[0][1] += w * x;
        M[1][0] += w * x;
        M[1][1] += w * x * x;
        b[0] += w * y;
        b[1] += w * x * y;
      }
      if (n < 2) return null;
      const params = solveLinear2(M, b);
      if (!params) return null;
      const [A0, A1] = params;
      let chi2 = 0.0;
      for (let i = 0; i < xVals.length; i += 1) {
        const x = Number(xVals[i]);
        const y = Number(yVals[i]);
        const e = Number(errVals?.[i]);
        if (!(Number.isFinite(x) && Number.isFinite(y))) continue;
        const sem = Number.isFinite(e) && e > 0 ? e : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        const res = y - (A0 + A1 * x);
        chi2 += w * res * res;
      }
      const cov = invert2(M);
      const errA0 = cov && Number.isFinite(cov[0][0]) ? Math.sqrt(Math.max(0, cov[0][0])) : NaN;
      const errA1 = cov && Number.isFinite(cov[1][1]) ? Math.sqrt(Math.max(0, cov[1][1])) : NaN;
      return {
        A0,
        A1,
        errA0,
        errA1,
        chi2,
        dof: n - 2,
        n,
      };
    }

    function buildWeightedConstant(yVals, errVals) {
      if (!Array.isArray(yVals) || yVals.length < 2) return null;
      let sw = 0.0;
      let swy = 0.0;
      let n = 0;
      for (let i = 0; i < yVals.length; i += 1) {
        const y = Number(yVals[i]);
        const e = Number(errVals?.[i]);
        if (!Number.isFinite(y)) continue;
        const sem = Number.isFinite(e) && e > 0 ? e : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        sw += w;
        swy += w * y;
        n += 1;
      }
      if (!(n >= 2 && sw > 0)) return null;
      const A0 = swy / sw;
      const errA0 = Math.sqrt(1.0 / sw);
      let chi2 = 0.0;
      for (let i = 0; i < yVals.length; i += 1) {
        const y = Number(yVals[i]);
        const e = Number(errVals?.[i]);
        if (!Number.isFinite(y)) continue;
        const sem = Number.isFinite(e) && e > 0 ? e : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        const res = y - A0;
        chi2 += w * res * res;
      }
      return {
        A0,
        errA0,
        chi2,
        dof: n - 1,
        n,
      };
    }

    function fmtPM(v, e, digits = 6) {
      const vv = Number.isFinite(v) ? v.toFixed(digits) : "-";
      const ee = Number.isFinite(e) ? e.toFixed(digits) : "-";
      return `${vv} ± ${ee}`;
    }

    function fmtMaybe(v, digits = 6) {
      return Number.isFinite(v) ? v.toFixed(digits) : "-";
    }

    function agreementClassName(level) {
      const x = String(level || "").toLowerCase();
      if (x === "green") return "agreement-green";
      if (x === "yellow") return "agreement-yellow";
      if (x === "red") return "agreement-red";
      return "agreement-na";
    }

    function signalBadgeText(level) {
      const x = String(level || "").toLowerCase();
      if (x === "green") return "good";
      if (x === "yellow") return "watch";
      if (x === "red") return "warn";
      return "n/a";
    }

    function setSignalNote(id, level, text, badgeText = "") {
      const root = document.getElementById(id);
      if (!root) return;
      const pill = root.querySelector(".agreement-pill");
      const msg = root.querySelector(".signal-text");
      const lvl = String(level || "na").toLowerCase();
      if (pill) {
        pill.className = `agreement-pill ${agreementClassName(lvl)}`;
        pill.textContent = String(badgeText || signalBadgeText(lvl));
      }
      if (msg) {
        msg.textContent = String(text || "");
      }
    }

    function classifyAgreementWithReference(value, err, reference) {
      const v = Number(value);
      const e = Number(err);
      const r = Number(reference);
      if (!(Number.isFinite(v) && Number.isFinite(e) && e > 0 && Number.isFinite(r))) {
        return { level: "na", text: "n/a" };
      }
      const consistentWithReference = Math.abs(v - r) <= (2.0 * e);
      if (!consistentWithReference) {
        return { level: "red", text: "disagree" };
      }
      const z = Math.abs(v) / e;
      if (z < 1.0) {
        return { level: "yellow", text: "agree, weak significance" };
      }
      if (z < 2.0) {
        return { level: "yellow", text: "agree, moderate significance" };
      }
      return { level: "green", text: "agree, strong non-zero" };
    }

    function summarizePotentialStability(pot, fit) {
      if (!pot || !fit) {
        return { reliable: false, level: "yellow", reason: "fit unavailable", details: [] };
      }
      const rows = Array.isArray(pot.pairByR) ? pot.pairByR : [];
      const tFits = rows.filter((r) => r?.method === "t_fit");
      const nTFits = tFits.length;
      const nMixed = tFits.filter((r) => String(r?.signMode || "") === "mixed").length;
      const nInflated = tFits.filter((r) => Number.isFinite(Number(r?.semInflation)) && Number(r.semInflation) > 1.25).length;
      const fracMixed = nTFits > 0 ? (nMixed / nTFits) : 0.0;
      const fracInflated = nTFits > 0 ? (nInflated / nTFits) : 0.0;
      const chi2dof = Number(fit?.chi2dof);
      const poorChi2 = Number.isFinite(chi2dof) && chi2dof > 4.0;
      const lowStats = Number(pot?.ncfg) < 16;

      const details = [];
      if (lowStats) details.push(`low stats (N=${pot?.ncfg || 0})`);
      if (poorChi2) details.push(`Cornell χ²/dof=${chi2dof.toFixed(2)}`);
      if (nTFits > 0 && fracMixed >= 0.5) details.push(`mixed-sign T-fits ${nMixed}/${nTFits}`);
      if (nTFits > 0 && fracInflated >= 0.5) details.push(`inflated sem ${nInflated}/${nTFits}`);

      const reliable = !lowStats && !poorChi2 && fracMixed < 0.5 && fracInflated < 0.5;
      if (reliable) return { reliable: true, level: "green", reason: "stable", details };
      return {
        reliable: false,
        level: poorChi2 ? "red" : "yellow",
        reason: details.join(", ") || "fit instability",
        details,
      };
    }

    function softenAgreementForUnstablePotential(agreement, stability) {
      const base = agreement || { level: "na", text: "n/a" };
      if (!stability || stability.reliable) return base;
      const lvl = String(base.level || "na").toLowerCase();
      if (lvl === "na") return base;
      return {
        level: "yellow",
        text: `inconclusive (${stability.reason || "fit unstable"})`,
      };
    }

    function solveLinear3(mat, vec) {
      if (!Array.isArray(mat) || mat.length !== 3 || !Array.isArray(vec) || vec.length !== 3) return null;
      const a = mat.map((row, i) => [Number(row?.[0]), Number(row?.[1]), Number(row?.[2]), Number(vec[i])]);
      for (let col = 0; col < 3; col += 1) {
        let pivot = col;
        for (let r = col + 1; r < 3; r += 1) {
          if (Math.abs(a[r][col]) > Math.abs(a[pivot][col])) pivot = r;
        }
        if (!(Math.abs(a[pivot][col]) > 1e-14)) return null;
        if (pivot !== col) {
          const tmp = a[col];
          a[col] = a[pivot];
          a[pivot] = tmp;
        }
        const inv = 1.0 / a[col][col];
        for (let c = col; c < 4; c += 1) a[col][c] *= inv;
        for (let r = 0; r < 3; r += 1) {
          if (r === col) continue;
          const f = a[r][col];
          if (!(Math.abs(f) > 0)) continue;
          for (let c = col; c < 4; c += 1) a[r][c] -= f * a[col][c];
        }
      }
      return [a[0][3], a[1][3], a[2][3]];
    }

    function invert3(mat) {
      if (!Array.isArray(mat) || mat.length !== 3) return null;
      const a = mat.map((row, i) => [
        Number(row?.[0]), Number(row?.[1]), Number(row?.[2]),
        i === 0 ? 1 : 0, i === 1 ? 1 : 0, i === 2 ? 1 : 0,
      ]);
      for (let col = 0; col < 3; col += 1) {
        let pivot = col;
        for (let r = col + 1; r < 3; r += 1) {
          if (Math.abs(a[r][col]) > Math.abs(a[pivot][col])) pivot = r;
        }
        if (!(Math.abs(a[pivot][col]) > 1e-14)) return null;
        if (pivot !== col) {
          const tmp = a[col];
          a[col] = a[pivot];
          a[pivot] = tmp;
        }
        const inv = 1.0 / a[col][col];
        for (let c = col; c < 6; c += 1) a[col][c] *= inv;
        for (let r = 0; r < 3; r += 1) {
          if (r === col) continue;
          const f = a[r][col];
          if (!(Math.abs(f) > 0)) continue;
          for (let c = col; c < 6; c += 1) a[r][c] -= f * a[col][c];
        }
      }
      return [
        [a[0][3], a[0][4], a[0][5]],
        [a[1][3], a[1][4], a[1][5]],
        [a[2][3], a[2][4], a[2][5]],
      ];
    }

    function fitCornellPotential(pot) {
      if (!pot || !Array.isArray(pot.Rs) || !Array.isArray(pot.means) || !Array.isArray(pot.sems)) return null;
      const pts = [];
      for (let i = 0; i < pot.Rs.length; i += 1) {
        const R = Number(pot.Rs[i]);
        const y = Number(pot.means[i]);
        const semRaw = Number(pot.sems[i]);
        if (!(Number.isFinite(R) && Number.isFinite(y) && R > 0)) continue;
        const sem = Number.isFinite(semRaw) && semRaw > 0 ? semRaw : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        pts.push({ R, y, w });
      }
      if (pts.length < 3) return null;

      const M = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
      ];
      const b = [0, 0, 0];
      for (const p of pts) {
        const x = [1.0, p.R, -1.0 / p.R];
        for (let i = 0; i < 3; i += 1) {
          b[i] += p.w * x[i] * p.y;
          for (let j = 0; j < 3; j += 1) {
            M[i][j] += p.w * x[i] * x[j];
          }
        }
      }
      const params = solveLinear3(M, b);
      if (!params) return null;
      const [V0, sigma, e] = params;
      if (!(Number.isFinite(V0) && Number.isFinite(sigma) && Number.isFinite(e))) return null;

      let chi2 = 0.0;
      for (const p of pts) {
        const pred = V0 + sigma * p.R - e / p.R;
        const r = p.y - pred;
        chi2 += p.w * r * r;
      }
      const dof = pts.length - 3;
      const cov = invert3(M);
      const errV0 = cov && Number.isFinite(cov[0][0]) ? Math.sqrt(Math.max(0, cov[0][0])) : NaN;
      const errSigma = cov && Number.isFinite(cov[1][1]) ? Math.sqrt(Math.max(0, cov[1][1])) : NaN;
      const errE = cov && Number.isFinite(cov[2][2]) ? Math.sqrt(Math.max(0, cov[2][2])) : NaN;

      return {
        V0,
        sigma,
        e,
        errV0,
        errSigma,
        errE,
        chi2,
        dof,
        chi2dof: dof > 0 ? (chi2 / dof) : NaN,
        n: pts.length,
        fitFn: (R) => V0 + sigma * R - e / R,
      };
    }

    function fitCornellPotentialFixedE(pot, eFixed = Math.PI / 12) {
      if (!pot || !Array.isArray(pot.Rs) || !Array.isArray(pot.means) || !Array.isArray(pot.sems)) return null;
      const pts = [];
      for (let i = 0; i < pot.Rs.length; i += 1) {
        const R = Number(pot.Rs[i]);
        const y = Number(pot.means[i]);
        const semRaw = Number(pot.sems[i]);
        if (!(Number.isFinite(R) && Number.isFinite(y) && R > 0)) continue;
        const sem = Number.isFinite(semRaw) && semRaw > 0 ? semRaw : 1.0;
        const w = 1.0 / Math.max(1e-12, sem * sem);
        const yAdj = y + eFixed / R;
        pts.push({ R, y, yAdj, w });
      }
      if (pts.length < 2) return null;

      const M = [
        [0, 0],
        [0, 0],
      ];
      const b = [0, 0];
      for (const p of pts) {
        const x0 = 1.0;
        const x1 = p.R;
        M[0][0] += p.w * x0 * x0;
        M[0][1] += p.w * x0 * x1;
        M[1][0] += p.w * x1 * x0;
        M[1][1] += p.w * x1 * x1;
        b[0] += p.w * x0 * p.yAdj;
        b[1] += p.w * x1 * p.yAdj;
      }
      const params = solveLinear2(M, b);
      if (!params) return null;
      const [V0, sigma] = params;
      if (!(Number.isFinite(V0) && Number.isFinite(sigma))) return null;

      let chi2 = 0.0;
      for (const p of pts) {
        const pred = V0 + sigma * p.R - eFixed / p.R;
        const r = p.y - pred;
        chi2 += p.w * r * r;
      }
      const dof = pts.length - 2;
      const cov = invert2(M);
      const errV0 = cov && Number.isFinite(cov[0][0]) ? Math.sqrt(Math.max(0, cov[0][0])) : NaN;
      const errSigma = cov && Number.isFinite(cov[1][1]) ? Math.sqrt(Math.max(0, cov[1][1])) : NaN;
      return {
        V0,
        sigma,
        e: eFixed,
        errV0,
        errSigma,
        errE: 0.0,
        chi2,
        dof,
        chi2dof: dof > 0 ? (chi2 / dof) : NaN,
        n: pts.length,
        k: 2,
        aic: chi2 + 2 * 2,
        fitFn: (R) => V0 + sigma * R - eFixed / R,
      };
    }

    function computeForcePoints(pot) {
      const out = [];
      if (!pot || !Array.isArray(pot.Rs) || !Array.isArray(pot.means)) return out;
      for (let i = 0; i + 1 < pot.Rs.length; i += 1) {
        const r0 = Number(pot.Rs[i]);
        const r1 = Number(pot.Rs[i + 1]);
        const v0 = Number(pot.means[i]);
        const v1 = Number(pot.means[i + 1]);
        const e0 = Number(pot.sems?.[i]);
        const e1 = Number(pot.sems?.[i + 1]);
        const dR = r1 - r0;
        if (!(Number.isFinite(r0) && Number.isFinite(r1) && Number.isFinite(v0) && Number.isFinite(v1) && dR > 0)) continue;
        const R = 0.5 * (r0 + r1);
        const F = (v1 - v0) / dR;
        const errF = (Number.isFinite(e0) && Number.isFinite(e1))
          ? Math.sqrt(Math.max(0, e0 * e0 + e1 * e1)) / dR
          : NaN;
        out.push({ R, F, errF, r0, r1, dR });
      }
      return out;
    }

    function solveScaleFromForce(forcePts, target) {
      const pts = (forcePts || [])
        .map((p) => {
          const r = Number(p?.R);
          const f = Number(p?.F);
          const ef = Number(p?.errF);
          if (!(Number.isFinite(r) && Number.isFinite(f) && r > 0)) return null;
          return {
            r,
            g: r * r * f,
            eg: Number.isFinite(ef) ? Math.abs(r * r * ef) : NaN,
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.r - b.r);
      if (pts.length < 2) return null;

      let best = null;
      for (let i = 0; i + 1 < pts.length; i += 1) {
        const p0 = pts[i];
        const p1 = pts[i + 1];
        if (!(Number.isFinite(p0.g) && Number.isFinite(p1.g))) continue;
        const d0 = p0.g - target;
        const d1 = p1.g - target;
        if (d0 === 0 || d1 === 0 || d0 * d1 < 0) {
          const slope = (p1.g - p0.g) / (p1.r - p0.r);
          if (!(Math.abs(slope) > 1e-12)) continue;
          const r = p0.r + (target - p0.g) / slope;
          const t = Math.max(0, Math.min(1, (r - p0.r) / Math.max(1e-12, p1.r - p0.r)));
          const eg = Number.isFinite(p0.eg) && Number.isFinite(p1.eg)
            ? (1 - t) * p0.eg + t * p1.eg
            : NaN;
          const err = Number.isFinite(eg) ? Math.abs(eg / slope) : NaN;
          const quality = Math.abs(target - 0.5 * (p0.g + p1.g));
          if (!best || quality < best.quality) {
            best = { value: r, err, quality, bracket: [p0.r, p1.r], points: pts.length };
          }
        }
      }
      return best;
    }

    function fitOneParameterProfile(rs, ys, es, kind = "gaussian") {
      const points = [];
      for (let i = 0; i < Math.min(rs.length, ys.length); i += 1) {
        const r = Number(rs[i]);
        const y = Number(ys[i]);
        const e = Number(es?.[i]);
        if (!(Number.isFinite(r) && Number.isFinite(y))) continue;
        points.push({ r, y, e: Number.isFinite(e) && e > 0 ? e : 1.0 });
      }
      if (points.length < 4) return null;
      const rMax = Math.max(...points.map((p) => p.r));
      const pMin = 0.05;
      const pMax = kind === "gaussian"
        ? Math.max(1.0, 2.0 * rMax * rMax + 0.25)
        : Math.max(0.5, 4.0 * rMax + 0.5);
      if (!(pMax > pMin)) return null;

      const nGrid = 160;
      const grid = [];
      for (let i = 0; i < nGrid; i += 1) {
        const t = i / Math.max(1, nGrid - 1);
        const p = pMin * Math.exp(Math.log(pMax / pMin) * t);
        const xVals = points.map((pt) => (
          kind === "gaussian"
            ? Math.exp(-(pt.r * pt.r) / (2 * p))
            : Math.exp(-pt.r / p)
        ));
        const yVals = points.map((pt) => pt.y);
        const eVals = points.map((pt) => pt.e);
        const fit = buildWeightedLinear2(xVals, yVals, eVals);
        if (!fit) continue;
        grid.push({
          p,
          A: fit.A1,
          C: fit.A0,
          chi2: fit.chi2,
          dof: points.length - 3,
        });
      }
      if (grid.length === 0) return null;
      grid.sort((a, b) => a.chi2 - b.chi2);
      const best = grid[0];
      const within = grid.filter((g) => g.chi2 <= best.chi2 + 1.0);
      const pErr = within.length > 1
        ? 0.5 * (Math.max(...within.map((x) => x.p)) - Math.min(...within.map((x) => x.p)))
        : NaN;
      return {
        kind,
        param: best.p,
        errParam: pErr,
        A: best.A,
        C: best.C,
        chi2: best.chi2,
        dof: best.dof,
        chi2dof: best.dof > 0 ? (best.chi2 / best.dof) : NaN,
        n: points.length,
      };
    }

    function parseFluxRFromKey(key) {
      const txt = String(key || "");
      const m = txt.match(/(?:^|_)R(\d+)(?:_|$)/i);
      if (m) return Number(m[1]);
      const m2 = txt.match(/^(\d+)$/);
      return m2 ? Number(m2[1]) : NaN;
    }

    function extractFluxProfileArray(v) {
      if (Array.isArray(v)) return v;
      if (!v || typeof v !== "object") return null;
      const candidates = [
        v.flux_profile_r_perp,
        v.profile_r_perp,
        v.profile,
        v.values,
      ];
      for (const c of candidates) {
        if (Array.isArray(c)) return c;
      }
      return null;
    }

    function collectFluxProfilesByR(ms, meta) {
      const byR = {};
      const defaultR = toFiniteNumber(meta?.flux_r, NaN);
      const objKeys = [
        "flux_profiles_r_perp",
        "flux_profiles",
        "flux_profile_by_rt",
        "flux_profile_by_r",
      ];
      for (const m of (ms || [])) {
        let mapped = false;
        for (const key of objKeys) {
          const obj = m?.[key];
          if (!obj || typeof obj !== "object" || Array.isArray(obj)) continue;
          for (const [k, v] of Object.entries(obj)) {
            const R = parseFluxRFromKey(k);
            const prof = extractFluxProfileArray(v);
            if (!(Number.isFinite(R) && Array.isArray(prof))) continue;
            if (!Array.isArray(byR[R])) byR[R] = [];
            byR[R].push(prof.map((x) => toFiniteNumber(x, NaN)));
            mapped = true;
          }
        }
        if (!mapped && Number.isFinite(defaultR) && Array.isArray(m?.flux_profile_r_perp)) {
          if (!Array.isArray(byR[defaultR])) byR[defaultR] = [];
          byR[defaultR].push(m.flux_profile_r_perp.map((x) => toFiniteNumber(x, NaN)));
        }
      }
      return byR;
    }

    function fitWidthGrowth(widthRows) {
      const pts = (widthRows || [])
        .map((x) => ({
          R: Number(x?.R),
          w2: Number(x?.w2),
          err: Number(x?.err),
        }))
        .filter((x) => Number.isFinite(x.R) && x.R > 0 && Number.isFinite(x.w2));
      if (pts.length < 3) return null;
      const xs = pts.map((p) => Math.log(p.R));
      const ys = pts.map((p) => p.w2);
      const es = pts.map((p) => (Number.isFinite(p.err) && p.err > 0 ? p.err : Math.max(1e-3, 0.15 * Math.abs(p.w2))));
      const fit = buildWeightedLinear2(xs, ys, es);
      if (!fit) return null;
      return {
        A: fit.A0,
        B: fit.A1,
        errA: fit.errA0,
        errB: fit.errA1,
        chi2: fit.chi2,
        dof: fit.dof,
        chi2dof: fit.dof > 0 ? fit.chi2 / fit.dof : NaN,
        n: fit.n,
      };
    }

    function estimateTauInt(series, maxLag = 200, cWindow = 4.0) {
      const vals = (series || []).map((x) => Number(x)).filter(Number.isFinite);
      const n = vals.length;
      if (n < 2) {
        return { n, tauInt: 0.5, rho: [1.0], maxLagUsed: 0, windowLag: 0, variance: NaN };
      }
      const mu = vals.reduce((a, b) => a + b, 0) / n;
      const centered = vals.map((x) => x - mu);
      const variance = centered.reduce((a, b) => a + b * b, 0) / n;
      if (!(variance > 0)) {
        return { n, tauInt: 0.5, rho: [1.0], maxLagUsed: 0, windowLag: 0, variance };
      }

      const maxLagUsed = Math.max(1, Math.min(Math.floor(maxLag), Math.floor(n / 2)));
      const rho = [1.0];
      let tau = 0.5;
      let windowLag = maxLagUsed;
      for (let lag = 1; lag <= maxLagUsed; lag += 1) {
        let c = 0.0;
        const span = n - lag;
        for (let i = 0; i < span; i += 1) c += centered[i] * centered[i + lag];
        c /= span;
        const r = c / variance;
        if (!Number.isFinite(r)) break;
        rho.push(r);
        tau += r;
        if (lag >= cWindow * Math.max(0.5, tau)) {
          windowLag = lag;
          break;
        }
      }
      return {
        n,
        tauInt: Math.max(0.5, tau),
        rho,
        maxLagUsed,
        windowLag,
        variance,
      };
    }

    function renderAutocorr(ms) {
      const plaq = (ms || []).map((m) => toFiniteNumber(m?.plaquette, NaN)).filter(Number.isFinite);
      const stats = estimateTauInt(plaq, 200, 4.0);
      const tau = stats.tauInt;
      const nEff = stats.n > 0 ? (stats.n / (2 * tau)) : NaN;
      const rho = stats.rho || [];
      const xs = Array.from({ length: rho.length }, (_, i) => i);
      const minRho = rho.length > 0 ? Math.min(...rho) : -0.2;
      const maxRho = rho.length > 0 ? Math.max(...rho) : 1.0;
      const minY = Math.min(-0.2, minRho - 0.05);
      const maxY = Math.max(1.0, maxRho + 0.05);
      drawXYLine("tauCanvas", xs, rho, {
        color: "#52adff",
        minX: 0,
        maxX: Math.max(1, xs.length - 1),
        minY,
        maxY,
        emptyText: "Not enough plaquette points yet",
      });

      document.getElementById("tauLabel").textContent =
        stats.n >= 8 ? `τ_int=${tau.toFixed(2)}` : "τ_int waiting for N>=8";
      document.getElementById("tauAxes").textContent =
        "x: lag (measurements), y: autocorrelation rho(lag) of plaquette";

      const rhoAt = (k) => (Number.isFinite(rho[k]) ? rho[k].toFixed(3) : "-");
      const suggestSkip = Math.max(1, Math.ceil(2 * Math.max(0.5, tau)));
      const lines = [
        `N=${stats.n}, τ_int=${tau.toFixed(3)}, N_eff~${Number.isFinite(nEff) ? nEff.toFixed(1) : "-"}`,
        `window_lag=${Math.round(stats.windowLag || 0)}, rho(1)=${rhoAt(1)}, rho(2)=${rhoAt(2)}, rho(5)=${rhoAt(5)}`,
        `suggested nskip >= ${suggestSkip} (rule-of-thumb 2×τ_int)`,
      ];
      document.getElementById("tauSummary").textContent = lines.join("\n");

      if (stats.n < 8) {
        setSignalNote("tauSignal", "na", `Need more plaquette points for τ_int (N=${stats.n}).`);
        return;
      }
      let level = "red";
      let verdict = "strong autocorrelation";
      if (Number.isFinite(nEff) && nEff >= 24 && tau <= 6.0) {
        level = "green";
        verdict = "independence looks good";
      } else if (Number.isFinite(nEff) && nEff >= 10) {
        level = "yellow";
        verdict = "usable but correlated";
      }
      setSignalNote(
        "tauSignal",
        level,
        `${verdict}: τ_int=${tau.toFixed(2)}, N_eff~${Number.isFinite(nEff) ? nEff.toFixed(1) : "-"}, suggest nskip≥${suggestSkip}.`
      );
    }

    function muIndexFromKey(key) {
      const m = /^mu(\d+)$/i.exec(String(key || ""));
      return m ? Number(m[1]) : NaN;
    }

    function renderPolyakov(ms) {
      const canvas = document.getElementById("polyCanvas");
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;
      const summaryEl = document.getElementById("polySummary");

      const keys = Array.from(new Set(
        (ms || []).flatMap((m) => Object.keys((m && m.polyakov_loops) || {}))
      )).sort((a, b) => {
        const ia = muIndexFromKey(a);
        const ib = muIndexFromKey(b);
        if (Number.isFinite(ia) && Number.isFinite(ib) && ia !== ib) return ia - ib;
        return String(a).localeCompare(String(b));
      });

      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      if (keys.length === 0) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        ctx.fillText("No Polyakov-loop data yet", 18, 28);
        document.getElementById("polyLabel").textContent = "Re P_mu unavailable";
        summaryEl.textContent = "No polyakov_loops in current measurements yet.\nNew samples appear after workers run updated measurement code.";
        setSignalNote("polySignal", "na", "No Polyakov-loop telemetry yet.");
        return;
      }

      const series = keys.map((k) => ({
        key: k,
        color: polyakovColorByMu[k] || "#c6a0ff",
        points: (ms || []).map((m, i) => {
          const y = toFiniteNumber(m?.polyakov_loops?.[k]?.re, NaN);
          return { x: i + 1, y };
        }).filter((p) => Number.isFinite(p.y)),
      }));
      const allVals = series.flatMap((s) => s.points.map((p) => p.y)).filter(Number.isFinite);
      if (allVals.length < 2) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        ctx.fillText("Not enough Polyakov points yet", 18, 28);
        document.getElementById("polyLabel").textContent = "Re P_mu pending";
        summaryEl.textContent = "Need at least 2 Polyakov points to draw sector history.";
        setSignalNote("polySignal", "na", "Need at least 2 Polyakov points.");
        return;
      }

      const n = ms.length;
      const maxAbs = Math.max(0.02, ...allVals.map((v) => Math.abs(v)));
      const yMax = 1.15 * maxAbs;
      const yMin = -yMax;
      const xMin = 1;
      const xMax = Math.max(2, n);

      const padL = 54;
      const padR = 20;
      const padT = 28;
      const padB = 34;
      const iw = Math.max(1, w - padL - padR);
      const ih = Math.max(1, h - padT - padB);
      const mapX = (x) => padL + ((x - xMin) / Math.max(1e-9, xMax - xMin)) * iw;
      const mapY = (y) => padT + (1 - (y - yMin) / Math.max(1e-12, yMax - yMin)) * ih;

      ctx.strokeStyle = "#34435f";
      ctx.lineWidth = 1;
      ctx.strokeRect(padL, padT, iw, ih);

      const y0 = mapY(0);
      ctx.strokeStyle = "rgba(255, 208, 120, 0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padL, y0);
      ctx.lineTo(padL + iw, y0);
      ctx.stroke();

      let legendX = padL + 2;
      const legendY = 12;
      ctx.font = "11px sans-serif";
      for (const s of series) {
        const label = s.key.toUpperCase();
        ctx.strokeStyle = s.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(legendX, legendY);
        ctx.lineTo(legendX + 12, legendY);
        ctx.stroke();
        ctx.fillStyle = "#cbd7ea";
        ctx.fillText(label, legendX + 16, legendY + 4);
        legendX += 20 + ctx.measureText(label).width + 14;
      }

      for (const s of series) {
        if (s.points.length < 2) continue;
        ctx.strokeStyle = s.color;
        ctx.lineWidth = 1.8;
        let open = false;
        for (const p of s.points) {
          const x = mapX(p.x);
          const y = mapY(p.y);
          if (!open) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            open = true;
          } else {
            ctx.lineTo(x, y);
          }
        }
        if (open) ctx.stroke();
      }

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "11px sans-serif";
      ctx.fillText(String(xMin), padL, h - 8);
      ctx.fillText(String(xMax), Math.max(padL + 6, padL + iw - 12), h - 8);
      ctx.fillText(yMin.toExponential(2), 6, h - 8);
      ctx.fillText(yMax.toExponential(2), 6, 16);

      const eps = Math.max(1e-5, 0.05 * maxAbs);
      const lines = [];
      let nearZeroCount = 0;
      let strongNonZeroCount = 0;
      for (const s of series) {
        const vals = s.points.map((p) => p.y);
        const st = meanSem(vals);
        const pull = st && st.sem > 0 ? Math.abs(st.mean) / st.sem : NaN;
        if (Number.isFinite(pull) && pull <= 2.0) nearZeroCount += 1;
        if (Number.isFinite(pull) && pull >= 3.0) strongNonZeroCount += 1;
        const pos = vals.filter((v) => v > eps).length;
        const neg = vals.filter((v) => v < -eps).length;
        const zeroish = vals.length - pos - neg;
        const nVals = vals.length;
        lines.push(
          `${s.key}: <ReP>=${st ? st.mean.toExponential(3) : "-"} ± ${st ? st.sem.toExponential(2) : "-"} | +:${Math.round((100 * pos) / Math.max(1, nVals))}% -:${Math.round((100 * neg) / Math.max(1, nVals))}% ~0:${Math.round((100 * zeroish) / Math.max(1, nVals))}%`
        );
      }
      summaryEl.textContent = lines.join("\n");
      document.getElementById("polyLabel").textContent =
        `Re P_mu sectors, N=${ms.length}, epsilon=${eps.toExponential(2)}`;

      let polyLevel = "yellow";
      let polyText = `Mixed sector pattern (${nearZeroCount}/${series.length} μ near zero within 2σ).`;
      if (nearZeroCount === series.length) {
        polyLevel = "green";
        polyText = "Center-symmetry pattern consistent with confinement (all μ near zero within 2σ).";
      } else if (strongNonZeroCount > 0) {
        polyLevel = "red";
        polyText = `At least one μ shows non-zero Polyakov mean at >3σ (${strongNonZeroCount}/${series.length}).`;
      }
      setSignalNote("polySignal", polyLevel, polyText);
    }

    function computePotentialStatsForMode(ms, Rs, Ts, useLegacyFilter) {
      if (!useLegacyFilter) {
        const adjPairs = [];
        for (let i = 0; i + 1 < Ts.length; i += 1) adjPairs.push([Ts[i], Ts[i + 1]]);

        const means = [];
        const sems = [];
        const counts = [];
        const pairByR = [];
        let validCount = 0;
        let totalN = 0;
        let nTFit = 0;
        let nPairFallback = 0;

        for (const R of Rs) {
          const tFit = fitPotentialFromLoopMeansInT(ms, R, Ts);
          if (tFit) {
            const semAdj = effectiveTFitSem(tFit);
            const semForFit = Number.isFinite(semAdj.semEff) && semAdj.semEff > 0 ? semAdj.semEff : tFit.sem;
            means.push(tFit.mean);
            sems.push(semForFit);
            counts.push(tFit.n);
            pairByR.push({
              R,
              t0: tFit.t0,
              t1: tFit.t1,
              n: tFit.n,
              method: tFit.method || "t_fit",
              tValues: tFit.tValues,
              sign: tFit.sign,
              signMode: tFit.signMode,
              signChanges: tFit.signChanges,
              fitPoints: tFit.fitPoints,
              chi2dof: tFit.chi2dof,
              semRaw: tFit.sem,
              semForFit,
              semInflation: semAdj.inflation,
              semInflationNotes: semAdj.notes,
              plateauRef: tFit.plateauRef,
            });
            validCount += 1;
            totalN += tFit.n;
            nTFit += 1;
            continue;
          }

          const candidates = [];
          for (const [t0, t1] of adjPairs) {
            const k0 = `R${R}_T${t0}`;
            const k1 = `R${R}_T${t1}`;
            const st = allSampleRatioJackknifePairStats(ms, k0, k1, t1 - t0);
            if (!st) continue;
            candidates.push({ ...st, t0, t1 });
          }

          const chosen = choosePlateauCandidate(candidates);
          if (chosen) {
            means.push(chosen.mean);
            sems.push(chosen.sem);
            counts.push(chosen.n);
            pairByR.push({
              R,
              t0: chosen.t0,
              t1: chosen.t1,
              n: chosen.n,
              method: "pair",
              tValues: [chosen.t0, chosen.t1],
              sign: Number(chosen?.meanA) > 0 ? 1 : (Number(chosen?.meanA) < 0 ? -1 : 0),
              fitPoints: 1,
              chi2dof: NaN,
              semRaw: chosen.sem,
              semForFit: chosen.sem,
              semInflation: 1.0,
              semInflationNotes: [],
              plateauRef: chosen.plateauRef,
            });
            validCount += 1;
            totalN += chosen.n;
            nPairFallback += 1;
          } else {
            means.push(NaN);
            sems.push(NaN);
            counts.push(0);
            pairByR.push({
              R,
              t0: null,
              t1: null,
              n: 0,
              method: "none",
              tValues: [],
              sign: 0,
              fitPoints: 0,
              chi2dof: NaN,
              semRaw: NaN,
              semForFit: NaN,
              semInflation: NaN,
              semInflationNotes: [],
              plateauRef: "no same-sign adjacent pair",
            });
          }
        }

        if (validCount === 0) return null;
        return {
          t0: NaN,
          t1: NaN,
          Rs,
          means,
          sems,
          counts,
          ncfg: ms.length,
          validCount,
          totalN,
          pairByR,
          nTFit,
          nPairFallback,
          selection: "per_r_t_log_fit",
        };
      }

      const pairs = [];
      for (let i = 0; i + 1 < Ts.length; i += 1) pairs.push([Ts[i], Ts[i + 1]]);

      let best = null;
      for (const [t0, t1] of pairs) {
        const perR = [];
        let validCount = 0;
        let totalN = 0;
        for (const R of Rs) {
          const k0 = `R${R}_T${t0}`;
          const k1 = `R${R}_T${t1}`;
          const dt = t1 - t0;
          const stats = useLegacyFilter
            ? legacyPairStats(ms, k0, k1, dt)
            : allSampleJackknifePairStats(ms, k0, k1, dt);
          perR.push(stats);
          if (stats) {
            validCount += 1;
            totalN += stats.n;
          }
        }
        if (
          !best ||
          validCount > best.validCount ||
          (validCount === best.validCount && totalN > best.totalN) ||
          (validCount === best.validCount && totalN === best.totalN && t1 > best.t1)
        ) {
          best = { t0, t1, perR, validCount, totalN };
        }
      }
      if (!best || best.validCount === 0) return null;

      const means = [];
      const sems = [];
      const counts = [];
      for (let i = 0; i < Rs.length; i += 1) {
        const stats = best.perR[i];
        means.push(stats ? stats.mean : NaN);
        sems.push(stats ? stats.sem : NaN);
        counts.push(stats ? stats.n : 0);
      }
      const pairByR = [];
      for (let i = 0; i < Rs.length; i += 1) {
        pairByR.push({
          R: Rs[i],
          t0: best.t0,
          t1: best.t1,
          n: Number.isFinite(counts[i]) ? counts[i] : 0,
          plateauRef: "global pair",
        });
      }
      return {
        t0: best.t0,
        t1: best.t1,
        Rs,
        means,
        sems,
        counts,
        ncfg: ms.length,
        validCount: best.validCount,
        totalN: best.totalN,
        pairByR,
        selection: "global_adjacent_pair",
      };
    }

    function computePotentialStats(ms, meta) {
      const Rs = Array.isArray(meta?.R) ? meta.R.map(Number).filter(Number.isFinite) : [];
      const Ts = Array.isArray(meta?.T) ? meta.T.map(Number).filter(Number.isFinite).sort((a, b) => a - b) : [];
      if (Rs.length === 0 || Ts.length < 2 || ms.length === 0) return null;
      const useLegacyFilter = isLegacyFilterEnabled();
      const stats = computePotentialStatsForMode(ms, Rs, Ts, useLegacyFilter);
      if (!stats) return null;
      return { ...stats, mode: useLegacyFilter ? "legacy_filter" : "all_samples", fallbackReason: "" };
    }

    function setVFitRows(rows, emptyMessage = "Cornell fit unavailable.") {
      const body = document.getElementById("vFitBody");
      if (!body) return;
      if (!Array.isArray(rows) || rows.length === 0) {
        body.innerHTML = `<tr><td colspan="5" class="hint">${escapeHtml(emptyMessage)}</td></tr>`;
        return;
      }
      body.innerHTML = rows.map((row) => `
        <tr>
          <td>${escapeHtml(row.param || "-")}</td>
          <td class="fit-num">${escapeHtml(row.lattice || "-")}</td>
          <td class="fit-num">${escapeHtml(row.physical || "-")}</td>
          <td class="fit-ref">${escapeHtml(row.reference || "-")}</td>
          <td><span class="agreement-pill ${agreementClassName(row.agreementLevel)}">${escapeHtml(row.agreementText || "n/a")}</span></td>
        </tr>
      `).join("");
    }

    function setFluxDiagRows(rows, emptyMessage = "Flux diagnostics pending.") {
      const body = document.getElementById("fluxDiagBody");
      if (!body) return;
      if (!Array.isArray(rows) || rows.length === 0) {
        body.innerHTML = `<tr><td colspan="4" class="hint">${escapeHtml(emptyMessage)}</td></tr>`;
        return;
      }
      body.innerHTML = rows.map((row) => `
        <tr>
          <td>${escapeHtml(row.diag || "-")}</td>
          <td class="fit-num">${escapeHtml(row.value || "-")}</td>
          <td class="fit-ref">${escapeHtml(row.reference || "-")}</td>
          <td><span class="agreement-pill ${agreementClassName(row.agreementLevel)}">${escapeHtml(row.agreementText || "n/a")}</span></td>
        </tr>
      `).join("");
    }

    function renderCombinedPhysicalComparison() {
      const body = document.getElementById("physicalCompareBody");
      if (!body) return;
      const rows = [...(lastPotentialCompareRows || []), ...(lastFluxCompareRows || [])];
      if (!Array.isArray(rows) || rows.length === 0) {
        body.innerHTML = `<tr><td colspan="5" class="hint">Waiting for measurements...</td></tr>`;
        renderPhysicalReferenceList([]);
        setSignalNote("physicalCompareSignal", "na", "No physical-comparison rows yet. More measurements needed.");
        return;
      }
      body.innerHTML = rows.map((row) => `
        <tr>
          <td>${escapeHtml(row.domain || "-")}</td>
          <td>${escapeHtml(row.observable || "-")}</td>
          <td class="fit-num">${escapeHtml(row.measured || row.value || "-")}</td>
          <td class="fit-ref">${renderTargetWithRefsHtml(row)}</td>
          <td><span class="agreement-pill ${agreementClassName(row.agreementLevel)}">${escapeHtml(row.agreementText || "n/a")}</span></td>
        </tr>
      `).join("");
      renderPhysicalReferenceList(rows);

      let nGreen = 0;
      let nYellow = 0;
      let nRed = 0;
      let nNa = 0;
      const redObs = [];
      for (const row of rows) {
        const lvl = String(row?.agreementLevel || "na").toLowerCase();
        if (lvl === "green") nGreen += 1;
        else if (lvl === "yellow") nYellow += 1;
        else if (lvl === "red") {
          nRed += 1;
          if (redObs.length < 2) redObs.push(`${row?.domain || "?"} ${row?.observable || "?"}`);
        } else nNa += 1;
      }

      const countTxt = `rows=${rows.length}, green=${nGreen}, yellow=${nYellow}, red=${nRed}, n/a=${nNa}`;
      if (nRed === 0 && nYellow === 0 && nGreen > 0) {
        setSignalNote(
          "physicalCompareSignal",
          "green",
          `Physical comparisons in good agreement; non-zero signals present where expected (${countTxt}).`
        );
      } else if (nRed === 0 && (nYellow > 0 || nNa > 0)) {
        if (nGreen === 0) {
          setSignalNote(
            "physicalCompareSignal",
            "yellow",
            `No disagreement yet, but no robust non-zero agreement either; uncertainty-limited stage, more stats needed (${countTxt}).`
          );
        } else {
          setSignalNote(
            "physicalCompareSignal",
            "yellow",
            `Mixed but consistent: some observables agree, others remain uncertainty-limited (${countTxt}).`
          );
        }
      } else if (nRed > 0) {
        const redTxt = redObs.length > 0 ? ` Example tension: ${redObs.join("; ")}.` : "";
        setSignalNote(
          "physicalCompareSignal",
          "red",
          `At least one observable disagrees with reference expectations.${redTxt} Recheck fit stability and accumulate more measurements (${countTxt}).`
        );
      } else {
        setSignalNote(
          "physicalCompareSignal",
          "na",
          `Physical-comparison status pending (${countTxt}).`
        );
      }
    }

    function renderFluxDiagnostics(ms, meta) {
      const byR = collectFluxProfilesByR(ms, meta);
      const Rs = Object.keys(byR).map((x) => Number(x)).filter(Number.isFinite).sort((a, b) => a - b);
      if (Rs.length === 0) {
        setFluxDiagRows([], "No flux profiles available for shape diagnostics yet.");
        setSignalNote("fluxSignal", "na", "Need flux-profile samples before shape diagnostics.");
        lastFluxCompareRows = [];
        renderCombinedPhysicalComparison();
        return;
      }

      const rows = [];
      const compareRows = [];
      const widthRows = [];
      let bestContrast = null;

      for (const R of Rs) {
        const profiles = byR[R] || [];
        if (!Array.isArray(profiles) || profiles.length === 0) continue;
        const stats = pointwiseMeanSem(profiles);
        const ysAll = stats.mean || [];
        const esAll = ysAll.map((_, i) => 0.5 * Math.abs(toFiniteNumber(stats.high?.[i], NaN) - toFiniteNumber(stats.low?.[i], NaN)));
        const rs = [];
        const ys = [];
        const es = [];
        for (let i = 0; i < ysAll.length; i += 1) {
          const y = toFiniteNumber(ysAll[i], NaN);
          if (!Number.isFinite(y)) continue;
          rs.push(i);
          ys.push(y);
          es.push(esAll[i]);
        }
        const gauss = fitOneParameterProfile(rs, ys, es, "gaussian");
        const expo = fitOneParameterProfile(rs, ys, es, "exponential");
        if (gauss && Number.isFinite(gauss.param) && gauss.param > 0) {
          widthRows.push({
            R,
            w2: gauss.param,
            err: Number.isFinite(gauss.errParam) && gauss.errParam > 0 ? gauss.errParam : Math.max(1e-3, 0.2 * gauss.param),
          });
        }
        const gTxt = gauss
          ? `w²=${fmtPM(gauss.param, gauss.errParam, 3)}, χ²/dof=${Number.isFinite(gauss.chi2dof) ? gauss.chi2dof.toFixed(2) : "-"}`
          : "w²=n/a";
        const eTxt = expo
          ? `λ=${fmtPM(expo.param, expo.errParam, 3)}, χ²/dof=${Number.isFinite(expo.chi2dof) ? expo.chi2dof.toFixed(2) : "-"}`
          : "λ=n/a";

        const bestChi2 = Math.min(
          Number.isFinite(gauss?.chi2dof) ? gauss.chi2dof : Infinity,
          Number.isFinite(expo?.chi2dof) ? expo.chi2dof : Infinity
        );
        let quality = { level: "na", text: "n/a" };
        if (Number.isFinite(bestChi2)) {
          if (bestChi2 < 1.5) quality = { level: "green", text: "good fit" };
          else if (bestChi2 < 3.0) quality = { level: "yellow", text: "usable fit" };
          else quality = { level: "red", text: "poor fit" };
        }

        rows.push({
          diag: `R=${R} profile shape`,
          value: `Gaussian: ${gTxt} | Exponential: ${eTxt}`,
          reference: "Models: C+A exp(-r⊥²/(2w²)) and C+A exp(-r⊥/λ)",
          agreementLevel: quality.level,
          agreementText: quality.text,
        });

        const finiteIdx = [];
        for (let i = 0; i < ysAll.length; i += 1) {
          if (Number.isFinite(toFiniteNumber(ysAll[i], NaN))) finiteIdx.push(i);
        }
        if (finiteIdx.length >= 3) {
          const centerIdx = finiteIdx[0];
          const tailN = Math.max(1, Math.floor(finiteIdx.length / 4));
          const tailIdxs = finiteIdx.slice(-tailN);
          const center = toFiniteNumber(ysAll[centerIdx], NaN);
          const centerSem = 0.5 * Math.abs(
            toFiniteNumber(stats.high?.[centerIdx], NaN) - toFiniteNumber(stats.low?.[centerIdx], NaN)
          );
          let tailMean = 0.0;
          let tailSem2 = 0.0;
          for (const i of tailIdxs) {
            const y = toFiniteNumber(ysAll[i], NaN);
            const sem = 0.5 * Math.abs(toFiniteNumber(stats.high?.[i], NaN) - toFiniteNumber(stats.low?.[i], NaN));
            tailMean += y;
            if (Number.isFinite(sem)) tailSem2 += sem * sem;
          }
          tailMean /= Math.max(1, tailIdxs.length);
          const tailSem = Math.sqrt(Math.max(0.0, tailSem2)) / Math.max(1, tailIdxs.length);
          const amp = Math.abs(center - tailMean);
          const ampSem = Math.sqrt(Math.max(1e-18, centerSem * centerSem + tailSem * tailSem));
          const snr = amp / ampSem;
          if (
            Number.isFinite(amp) &&
            Number.isFinite(ampSem) &&
            (!bestContrast || (Number.isFinite(snr) && snr > bestContrast.snr))
          ) {
            bestContrast = { R, amp, ampSem, snr };
          }
        }
      }

      if (bestContrast) {
        let level = "red";
        let text = "weak";
        if (Number.isFinite(bestContrast.snr) && bestContrast.snr >= 3.0) {
          level = "green";
          text = "non-zero";
        } else if (Number.isFinite(bestContrast.snr) && bestContrast.snr >= 1.5) {
          level = "yellow";
          text = "emerging";
        }
        compareRows.push({
          domain: "Flux tube",
          observable: `Center-tail contrast ΔP(r⊥) (R=${bestContrast.R})`,
          measured: `${fmtPM(bestContrast.amp, bestContrast.ampSem, 6)}${Number.isFinite(bestContrast.snr) ? ` (${bestContrast.snr.toFixed(2)}σ)` : ""}`,
          target: "> 0 (tube profile differs from far-tail vacuum baseline)",
          refs: [],
          agreementLevel: level,
          agreementText: text,
        });
      }

      const growth = fitWidthGrowth(widthRows);
      if (growth) {
        let growAgreement = { level: "na", text: "n/a" };
        if (Number.isFinite(growth.B) && Number.isFinite(growth.errB) && growth.errB > 0) {
          if (Math.abs(growth.B) <= 2.0 * growth.errB) {
            growAgreement = { level: "yellow", text: "zero-consistent" };
          } else if (growth.B > 0) {
            growAgreement = { level: "green", text: "positive non-zero" };
          } else {
            growAgreement = { level: "red", text: "negative slope" };
          }
        }
        const gTxt = `A=${fmtPM(growth.A, growth.errA, 3)}, B=${fmtPM(growth.B, growth.errB, 3)}, χ²/dof=${Number.isFinite(growth.chi2dof) ? growth.chi2dof.toFixed(2) : "-"}`;
        rows.push({
          diag: "Width growth fit",
          value: gTxt,
          reference: "w²(R)=A+B ln R; expect B>0 for roughening",
          agreementLevel: growAgreement.level,
          agreementText: growAgreement.text,
        });
        compareRows.push({
          domain: "Flux tube",
          observable: "Width slope B in w²(R)=A+B ln R",
          measured: fmtPM(growth.B, growth.errB, 3),
          target: "B > 0 (log broadening expected)",
          refs: ["luscher_1981"],
          agreementLevel: growAgreement.level,
          agreementText: growAgreement.text,
        });
      } else {
        rows.push({
          diag: "Width growth fit",
          value: "Need ≥3 distinct R profiles with Gaussian widths",
          reference: "w²(R)=A+B ln R",
          agreementLevel: "na",
          agreementText: "n/a",
        });
      }

      setFluxDiagRows(rows);
      lastFluxCompareRows = compareRows;
      renderCombinedPhysicalComparison();
    }

    function renderPotential(ms, meta) {
      const pot = computePotentialStats(ms, meta);
      if (!pot) {
        document.getElementById("vLabel").textContent = "V(R) unavailable (insufficient valid loop-ratio points)";
        document.getElementById("vAxes").textContent = "x: R (lattice units), y: V(R)";
        document.getElementById("vTable").textContent = "No valid V(R) points yet.";
        document.getElementById("vForceTable").textContent = "Force diagnostics unavailable.";
        setVFitRows([], "Cornell fit unavailable (need >=3 valid V(R) points).");
        setSignalNote("vSignal", "na", "Need valid loop-ratio points before fitting V(R).");
        drawXYError("vCanvas", [], [], []);
        lastPotentialCompareRows = [];
        renderCombinedPhysicalComparison();
        return;
      }

      const supplemental = computePotentialSupplemental(ms, meta, pot);
      const extraPts = (supplemental?.extra || []).map((x) => ({
        x: x.R,
        y: x.mean,
        e: x.sem,
        label: `R=${x.R}`,
      }));

      const fit = fitCornellPotential(pot);
      const drawOpts = { extraPts };
      if (fit) {
        drawOpts.fitFn = fit.fitFn;
        drawOpts.fitColor = "rgba(82, 173, 255, 0.95)";
        drawOpts.fitWidth = 2;
      }
      drawXYError("vCanvas", pot.Rs, pot.means, pot.sems, "#f38ba8", drawOpts);
      const modeText = pot.mode === "legacy_filter"
        ? "legacy filtered per-sample log ratio"
        : (pot.selection === "per_r_t_log_fit"
          ? "all-sample per-R T-fit (Veff plateau fit, ln|W| fallback)"
        : (pot.selection === "per_r_plateau_adjacent"
          ? "all-sample per-R plateau (adjacent T, same-sign ratio incl. both-negative)"
          : "all-sample ratio with jackknife"));
      if (pot.selection === "per_r_t_log_fit") {
        document.getElementById("vLabel").textContent =
          `V(R) from per-R T-fits, N=${pot.ncfg}, mode=${modeText}, valid R=${pot.validCount}/${pot.Rs.length}, T-fit R=${pot.nTFit || 0}, pair-fallback R=${pot.nPairFallback || 0}${pot.fallbackReason ? ` (${pot.fallbackReason})` : ""}`;
        document.getElementById("vAxes").textContent =
          `x: R (lattice units), y: V(R) from per-R T-fits (plateau in Veff, ln|W| slope fallback)${extraPts.length > 0 ? ` | provisional gray points=${extraPts.length} (not used in fit)` : ""}`;
      } else if (pot.selection === "per_r_plateau_adjacent") {
        document.getElementById("vLabel").textContent =
          `V(R) from per-R adjacent-T plateaus, N=${pot.ncfg}, mode=${modeText}, valid R=${pot.validCount}/${pot.Rs.length}${pot.fallbackReason ? ` (${pot.fallbackReason})` : ""}`;
        document.getElementById("vAxes").textContent =
          `x: R (lattice units), y: V(R) from per-R -ln[W(R,T+1)/W(R,T)]${extraPts.length > 0 ? ` | provisional gray points=${extraPts.length} (not used in fit)` : ""}`;
      } else {
        document.getElementById("vLabel").textContent =
          `V(R) from -ln[W(R,${pot.t1})/W(R,${pot.t0})], N=${pot.ncfg}, mode=${modeText}, valid R=${pot.validCount}/${pot.Rs.length}${pot.fallbackReason ? ` (${pot.fallbackReason})` : ""}`;
        document.getElementById("vAxes").textContent =
          `x: R (lattice units), y: V(R) = -ln[W(R,${pot.t1})/W(R,${pot.t0})]${extraPts.length > 0 ? ` | provisional gray points=${extraPts.length} (not used in fit)` : ""}`;
      }

      const vrRows = [];
      for (let i = 0; i < pot.Rs.length; i += 1) {
        const R = pot.Rs[i];
        const m = pot.means[i];
        const e = pot.sems[i];
        const n = pot.counts[i];
        const pairInfo = Array.isArray(pot.pairByR) ? pot.pairByR[i] : null;
        let pairText = "";
        if ((pairInfo?.method === "t_fit" || pairInfo?.method === "t_plateau_fit") && Array.isArray(pairInfo.tValues) && pairInfo.tValues.length >= 3) {
          const signTxt = pairInfo?.signMode
            ? String(pairInfo.signMode)
            : (Number(pairInfo.sign) > 0 ? "+" : (Number(pairInfo.sign) < 0 ? "-" : "?"));
          const flipsTxt = Number.isFinite(Number(pairInfo?.signChanges)) && Number(pairInfo.signChanges) > 0
            ? `, sign-flips=${Math.round(Number(pairInfo.signChanges))}`
            : "";
          const chiTxt = Number.isFinite(Number(pairInfo.chi2dof)) ? Number(pairInfo.chi2dof).toFixed(2) : "-";
          const semInfl = Number(pairInfo.semInflation);
          const semAdjTxt = Number.isFinite(semInfl) && semInfl > 1.05
            ? `, sem×${semInfl.toFixed(2)}`
            : "";
          const fitKind = pairInfo?.method === "t_plateau_fit" ? "plateau-fit" : "ln|W| fit";
          pairText =
            ` | ${fitKind} sign=${signTxt}${flipsTxt}, T={${pairInfo.tValues.join(",")}}, χ²/dof=${chiTxt}${semAdjTxt}${pairInfo.plateauRef ? ` (${pairInfo.plateauRef})` : ""}`;
        } else if (pairInfo && Number.isFinite(Number(pairInfo.t0)) && Number.isFinite(Number(pairInfo.t1))) {
          pairText = ` | pair T${pairInfo.t0}->T${pairInfo.t1}${pairInfo.plateauRef ? ` (${pairInfo.plateauRef})` : ""}`;
        }
        if (Number.isFinite(m) && Number.isFinite(e) && n > 0) {
          vrRows.push(`R=${R}: V=${m.toFixed(6)} ± ${e.toFixed(6)} (n=${n}${pairText})`);
        } else {
          const reason = pairInfo?.plateauRef ? ` (${pairInfo.plateauRef})` : "";
          vrRows.push(`R=${R}: n/a${reason}`);
        }
      }
      for (const x of (supplemental?.extra || [])) {
        vrRows.push(
          `R=${x.R}: provisional V=${x.mean.toFixed(6)} ± ${x.sem.toFixed(6)} from sign-coherent all-sample pair T${x.t0}->T${x.t1} (not in fit/physics table)`
        );
      }
      for (const miss of (supplemental?.excluded || [])) {
        vrRows.push(`R=${miss.R}: excluded from unbiased V(R) for fit/comparison: ${miss.reason}`);
      }
      document.getElementById("vTable").textContent = vrRows.join("\n");

      if (!fit) {
        document.getElementById("vForceTable").textContent = "Force diagnostics unavailable (Cornell fit unavailable).";
        setVFitRows([], "Cornell fit unavailable (need ≥3 finite points with non-singular errors).");
        setSignalNote("vSignal", "yellow", "V(R) points exist, but fit is not stable yet (need more clean R values).");
        lastPotentialCompareRows = [];
        renderCombinedPhysicalComparison();
        return;
      }

      const potentialStability = summarizePotentialStability(pot, fit);

      const aFm = parseAFm(meta);
      const hasAFm = Number.isFinite(aFm) && aFm > 0;
      const aInvGeV = hasAFm ? (0.1973269804 / aFm) : NaN;

      const sigmaGeV2 = hasAFm ? fit.sigma * aInvGeV * aInvGeV : NaN;
      const sigmaGeV2Err = (hasAFm && Number.isFinite(fit.errSigma)) ? fit.errSigma * aInvGeV * aInvGeV : NaN;
      const sqrtSigmaMeV = sigmaGeV2 > 0 ? 1000 * Math.sqrt(sigmaGeV2) : NaN;
      const sqrtSigmaMeVErr = (sigmaGeV2 > 0 && Number.isFinite(sigmaGeV2Err))
        ? 500 * sigmaGeV2Err / Math.sqrt(sigmaGeV2)
        : NaN;
      const v0GeV = hasAFm ? fit.V0 * aInvGeV : NaN;
      const v0GeVErr = (hasAFm && Number.isFinite(fit.errV0)) ? fit.errV0 * aInvGeV : NaN;

      const eRef = Math.PI / 12;
      const eDelta = fit.e - eRef;
      const ePull = Number.isFinite(fit.errE) && fit.errE > 0 ? (eDelta / fit.errE) : NaN;
      const sigmaRefGeV2 = 0.1936;
      const sigmaRefGeV2Err = 0.0176;
      const sqrtSigmaRefMeV = 440.0;
      const sqrtSigmaRefMeVErr = 20.0;
      const r0RefFm = 0.50;
      const r0RefFmErr = 0.02;
      const r1RefFm = 0.31;
      const r1RefFmErr = 0.02;
      const sigmaAgreementRaw = hasAFm
        ? classifyAgreementWithReference(sigmaGeV2, sigmaGeV2Err, sigmaRefGeV2)
        : { level: "na", text: "n/a" };
      const sqrtSigmaAgreementRaw = hasAFm
        ? classifyAgreementWithReference(sqrtSigmaMeV, sqrtSigmaMeVErr, sqrtSigmaRefMeV)
        : { level: "na", text: "n/a" };
      const eAgreementRaw = classifyAgreementWithReference(fit.e, fit.errE, eRef);

      const rc = (fit.sigma > 0 && fit.e > 0) ? Math.sqrt(fit.e / fit.sigma) : NaN;
      const errRc = (Number.isFinite(rc) && fit.e > 0 && fit.sigma > 0 && Number.isFinite(fit.errE) && Number.isFinite(fit.errSigma))
        ? 0.5 * rc * Math.sqrt(
          (fit.errE / fit.e) * (fit.errE / fit.e) +
          (fit.errSigma / fit.sigma) * (fit.errSigma / fit.sigma)
        )
        : NaN;
      const aSqrtSigma = fit.sigma > 0 ? Math.sqrt(fit.sigma) : NaN;
      const errASqrtSigma = (fit.sigma > 0 && Number.isFinite(fit.errSigma))
        ? (0.5 * fit.errSigma / Math.sqrt(fit.sigma))
        : NaN;
      const aSqrtSigmaRef = hasAFm ? (0.440 / aInvGeV) : NaN;
      const aSqrtSigmaAgreementRaw = hasAFm
        ? classifyAgreementWithReference(aSqrtSigma, errASqrtSigma, aSqrtSigmaRef)
        : { level: "na", text: "n/a" };

      const forcePts = computeForcePoints(pot);
      const CF_SU2 = 0.75;
      const alphaPts = forcePts.map((p) => ({
        R: p.R,
        alpha: (p.R * p.R * p.F) / CF_SU2,
        err: Number.isFinite(p.errF) ? Math.abs((p.R * p.R * p.errF) / CF_SU2) : NaN,
      }));
      const alphaShort = alphaPts.length > 0 ? alphaPts[0] : null;

      const r0Force = solveScaleFromForce(forcePts, 1.65);
      const r1Force = solveScaleFromForce(forcePts, 1.0);

      const sommerFromFit = (cVal) => {
        if (!(fit.sigma > 0 && (cVal - fit.e) > 0)) return null;
        const value = Math.sqrt((cVal - fit.e) / fit.sigma);
        const de = Number.isFinite(fit.errE)
          ? (-1.0 / (2.0 * Math.sqrt(fit.sigma * (cVal - fit.e)))) * fit.errE
          : NaN;
        const ds = Number.isFinite(fit.errSigma)
          ? (-0.5 * Math.sqrt(cVal - fit.e) / Math.pow(fit.sigma, 1.5)) * fit.errSigma
          : NaN;
        const err = (Number.isFinite(de) && Number.isFinite(ds)) ? Math.sqrt(de * de + ds * ds) : NaN;
        return { value, err };
      };
      const r0Fit = sommerFromFit(1.65);
      const r1Fit = sommerFromFit(1.0);

      const r0Fm = (hasAFm && r0Force && Number.isFinite(r0Force.value)) ? r0Force.value * aFm : NaN;
      const r0FmErr = (hasAFm && r0Force && Number.isFinite(r0Force.err)) ? Math.abs(r0Force.err * aFm) : NaN;
      const r1Fm = (hasAFm && r1Force && Number.isFinite(r1Force.value)) ? r1Force.value * aFm : NaN;
      const r1FmErr = (hasAFm && r1Force && Number.isFinite(r1Force.err)) ? Math.abs(r1Force.err * aFm) : NaN;
      const r0AgreementRaw = hasAFm ? classifyAgreementWithReference(r0Fm, r0FmErr, 0.50) : { level: "na", text: "n/a" };
      const r1AgreementRaw = hasAFm ? classifyAgreementWithReference(r1Fm, r1FmErr, 0.31) : { level: "na", text: "n/a" };

      const sigmaAgreement = softenAgreementForUnstablePotential(sigmaAgreementRaw, potentialStability);
      const sqrtSigmaAgreement = softenAgreementForUnstablePotential(sqrtSigmaAgreementRaw, potentialStability);
      const eAgreement = softenAgreementForUnstablePotential(eAgreementRaw, potentialStability);
      const aSqrtSigmaAgreement = softenAgreementForUnstablePotential(aSqrtSigmaAgreementRaw, potentialStability);
      const r0Agreement = softenAgreementForUnstablePotential(r0AgreementRaw, potentialStability);
      const r1Agreement = softenAgreementForUnstablePotential(r1AgreementRaw, potentialStability);

      const fitFixed = fitCornellPotentialFixedE(pot, Math.PI / 12);
      const aicFree = fit.chi2 + 2 * 3;
      const aicFixed = fitFixed ? (fitFixed.chi2 + 2 * 2) : NaN;
      const deltaAIC = Number.isFinite(aicFixed) ? (aicFixed - aicFree) : NaN;
      let aicAgreement = { level: "na", text: "n/a" };
      if (Number.isFinite(deltaAIC)) {
        if (deltaAIC <= -2.0) aicAgreement = { level: "green", text: "fixed-e favored" };
        else if (Math.abs(deltaAIC) < 2.0) aicAgreement = { level: "yellow", text: "inconclusive" };
        else aicAgreement = { level: "red", text: "free-e favored" };
      }

      const forceLines = [];
      if (forcePts.length > 0) {
        forceLines.push("F(R_mid)=ΔV/ΔR, αqq(R_mid)=R_mid²F/C_F (SU(2): C_F=3/4):");
        for (const p of forcePts.slice(0, 8)) {
          const alpha = (p.R * p.R * p.F) / CF_SU2;
          const eAlpha = Number.isFinite(p.errF) ? Math.abs((p.R * p.R * p.errF) / CF_SU2) : NaN;
          forceLines.push(`R_mid=${p.R.toFixed(2)}: F=${fmtPM(p.F, p.errF, 6)} | αqq=${fmtPM(alpha, eAlpha, 4)}`);
        }
        if (forcePts.length > 8) forceLines.push(`... ${forcePts.length - 8} more force points`);
      } else {
        forceLines.push("Not enough V(R) points to form force diagnostics.");
      }
      if (r0Force) forceLines.push(`r₀/a from force (r²F=1.65): ${fmtPM(r0Force.value, r0Force.err, 4)}`);
      if (r1Force) forceLines.push(`r₁/a from force (r²F=1.00): ${fmtPM(r1Force.value, r1Force.err, 4)}`);
      document.getElementById("vForceTable").textContent = forceLines.join("\n");

      const fitRows = [
        {
          param: "a",
          lattice: hasAFm ? `${aFm.toFixed(6)} fm` : "-",
          physical: hasAFm ? `a⁻¹=${aInvGeV.toFixed(3)} GeV` : "set a(fm)",
          reference: "dashboard default or run metadata",
          agreementLevel: "na",
          agreementText: "n/a",
        },
        {
          param: "σ",
          lattice: fmtPM(fit.sigma, fit.errSigma, 6),
          physical: hasAFm ? `${fmtPM(sigmaGeV2, sigmaGeV2Err, 6)} GeV²` : "set a(fm)",
          reference: hasAFm && Number.isFinite(sigmaGeV2)
            ? `SU(3) ~${sigmaRefGeV2.toFixed(4)} GeV² | ratio ${fmtMaybe(sigmaGeV2 / sigmaRefGeV2, 2)}x`
            : `SU(3) ~${sigmaRefGeV2.toFixed(4)} GeV²`,
          agreementLevel: sigmaAgreement.level,
          agreementText: sigmaAgreement.text,
        },
        {
          param: "a√σ",
          lattice: fmtPM(aSqrtSigma, errASqrtSigma, 6),
          physical: hasAFm ? `ref≈${fmtMaybe(aSqrtSigmaRef, 6)} (from 440 MeV)` : "set a(fm)",
          reference: "dimensionless scaling check",
          agreementLevel: aSqrtSigmaAgreement.level,
          agreementText: aSqrtSigmaAgreement.text,
        },
        {
          param: "√σ",
          lattice: "-",
          physical: hasAFm ? `${fmtPM(sqrtSigmaMeV, sqrtSigmaMeVErr, 1)} MeV` : "set a(fm)",
          reference: hasAFm && Number.isFinite(sqrtSigmaMeV)
            ? `SU(3) ~${sqrtSigmaRefMeV.toFixed(0)} MeV | ratio ${fmtMaybe(sqrtSigmaMeV / sqrtSigmaRefMeV, 2)}x`
            : `SU(3) ~${sqrtSigmaRefMeV.toFixed(0)} MeV`,
          agreementLevel: sqrtSigmaAgreement.level,
          agreementText: sqrtSigmaAgreement.text,
        },
        {
          param: "e",
          lattice: fmtPM(fit.e, fit.errE, 6),
          physical: "-",
          reference: `Lüscher π/12=${eRef.toFixed(6)} | Δ=${fmtMaybe(eDelta, 6)}${Number.isFinite(ePull) ? ` (${fmtMaybe(ePull, 2)}σ)` : ""}`,
          agreementLevel: eAgreement.level,
          agreementText: eAgreement.text,
        },
        {
          param: "R_c/a",
          lattice: fmtPM(rc, errRc, 4),
          physical: hasAFm && Number.isFinite(rc) ? fmtPM(rc * aFm, Number.isFinite(errRc) ? errRc * aFm : NaN, 4) + " fm" : "-",
          reference: "R_c = sqrt(e/sigma), with V(R)=V0+sigma*R-e/R",
          agreementLevel: "na",
          agreementText: "n/a",
        },
        {
          param: "r₀/a",
          lattice: r0Force ? fmtPM(r0Force.value, r0Force.err, 4) : "-",
          physical: hasAFm && Number.isFinite(r0Fm) ? `${fmtPM(r0Fm, r0FmErr, 4)} fm` : "set a(fm)",
          reference: `r0^2 * F(r0) = 1.65, F=dV/dR${r0Fit ? ` | Cornell ${fmtPM(r0Fit.value, r0Fit.err, 4)}` : ""}`,
          agreementLevel: r0Agreement.level,
          agreementText: r0Agreement.text,
        },
        {
          param: "r₁/a",
          lattice: r1Force ? fmtPM(r1Force.value, r1Force.err, 4) : "-",
          physical: hasAFm && Number.isFinite(r1Fm) ? `${fmtPM(r1Fm, r1FmErr, 4)} fm` : "set a(fm)",
          reference: `r1^2 * F(r1) = 1.00, F=dV/dR${r1Fit ? ` | Cornell ${fmtPM(r1Fit.value, r1Fit.err, 4)}` : ""}`,
          agreementLevel: r1Agreement.level,
          agreementText: r1Agreement.text,
        },
        {
          param: "αqq(min R_mid)",
          lattice: alphaShort ? `${fmtPM(alphaShort.alpha, alphaShort.err, 4)} @ R=${alphaShort.R.toFixed(2)}` : "-",
          physical: "-",
          reference: "αqq(R)=R²F(R)/C_F, C_F=3/4 (SU(2))",
          agreementLevel: "na",
          agreementText: "n/a",
        },
        {
          param: "V₀",
          lattice: fmtPM(fit.V0, fit.errV0, 6),
          physical: hasAFm ? `${fmtPM(v0GeV, v0GeVErr, 6)} GeV` : "set a(fm)",
          reference: "additive constant",
          agreementLevel: "na",
          agreementText: "n/a",
        },
        {
          param: "χ²/dof",
          lattice: `${Number.isFinite(fit.chi2dof) ? fit.chi2dof.toFixed(3) : "-"} (${fit.chi2.toFixed(3)} / ${fit.dof})`,
          physical: `points=${fit.n}`,
          reference: "~1 is ideal if model/errors are consistent",
          agreementLevel: "na",
          agreementText: "n/a",
        },
        {
          param: "Fixed e=π/12 test",
          lattice: fitFixed
            ? `free χ²/dof=${Number.isFinite(fit.chi2dof) ? fit.chi2dof.toFixed(3) : "-"}, fixed=${Number.isFinite(fitFixed.chi2dof) ? fitFixed.chi2dof.toFixed(3) : "-"}`
            : "fixed fit unavailable",
          physical: Number.isFinite(deltaAIC) ? `ΔAIC=${deltaAIC.toFixed(3)} (fixed-free)` : "-",
          reference: "AIC comparison with fixed Lüscher term",
          agreementLevel: aicAgreement.level,
          agreementText: aicAgreement.text,
        },
      ];
      setVFitRows(fitRows);

      const sigmaPull = Number.isFinite(fit.errSigma) && fit.errSigma > 0
        ? (fit.sigma / fit.errSigma)
        : NaN;
      let vLevel = "red";
      let vText = `Cornell fit weak: σ=${fmtPM(fit.sigma, fit.errSigma, 4)}, χ²/dof=${Number.isFinite(fit.chi2dof) ? fit.chi2dof.toFixed(2) : "-"}.`;
      if (fit.sigma > 0 && Number.isFinite(sigmaPull) && sigmaPull >= 3.0 && Number.isFinite(fit.chi2dof) && fit.chi2dof <= 3.0) {
        vLevel = "green";
        vText = `Confining signal detected: σ=${fmtPM(fit.sigma, fit.errSigma, 4)} (${sigmaPull.toFixed(1)}σ), χ²/dof=${fit.chi2dof.toFixed(2)}.`;
      } else if (fit.sigma > 0 && Number.isFinite(sigmaPull) && sigmaPull >= 1.5) {
        vLevel = "yellow";
        vText = `Confining trend forming: σ=${fmtPM(fit.sigma, fit.errSigma, 4)} (${sigmaPull.toFixed(1)}σ), χ²/dof=${Number.isFinite(fit.chi2dof) ? fit.chi2dof.toFixed(2) : "-"}.`;
      } else if (fit.sigma <= 0) {
        vText = `Non-confining fit at current stats: σ=${fmtPM(fit.sigma, fit.errSigma, 4)}.`;
      }
      if (!potentialStability.reliable) {
        vLevel = potentialStability.level || "yellow";
        vText = `V(R) fit currently uncertainty-limited: ${potentialStability.reason}.`;
      }
      setSignalNote("vSignal", vLevel, vText);

      const aSqrtSigmaRefErr = hasAFm ? ((sqrtSigmaRefMeVErr / 1000.0) / aInvGeV) : NaN;
      const potentialCompareRows = [];
      potentialCompareRows.push({
        domain: "Potential",
        observable: "e in V(R)=V0+sigma*R-e/R",
        measured: fmtPM(fit.e, fit.errE, 6),
        target: `π/12 = ${eRef.toFixed(6)}`,
        refs: ["luscher_1981"],
        agreementLevel: eAgreement.level,
        agreementText: eAgreement.text,
      });
      if (hasAFm && Number.isFinite(sigmaGeV2) && Number.isFinite(sigmaGeV2Err)) {
        potentialCompareRows.push({
          domain: "Potential",
          observable: "sigma in V(R)=V0+sigma*R-e/R",
          measured: `${fmtPM(sigmaGeV2, sigmaGeV2Err, 6)} GeV²`,
          target: `${fmtPM(sigmaRefGeV2, sigmaRefGeV2Err, 6)} GeV² (SU(3) benchmark)`,
          refs: ["necco_sommer_2002"],
          agreementLevel: sigmaAgreement.level,
          agreementText: sigmaAgreement.text,
        });
      }
      if (hasAFm && Number.isFinite(sqrtSigmaMeV) && Number.isFinite(sqrtSigmaMeVErr)) {
        potentialCompareRows.push({
          domain: "Potential",
          observable: "√σ",
          measured: `${fmtPM(sqrtSigmaMeV, sqrtSigmaMeVErr, 1)} MeV`,
          target: `${fmtPM(sqrtSigmaRefMeV, sqrtSigmaRefMeVErr, 1)} MeV (SU(3) benchmark)`,
          refs: ["necco_sommer_2002"],
          agreementLevel: sqrtSigmaAgreement.level,
          agreementText: sqrtSigmaAgreement.text,
        });
      }
      if (Number.isFinite(aSqrtSigma) && Number.isFinite(errASqrtSigma) && Number.isFinite(aSqrtSigmaRef)) {
        potentialCompareRows.push({
          domain: "Potential",
          observable: "a√σ",
          measured: fmtPM(aSqrtSigma, errASqrtSigma, 6),
          target: fmtPM(aSqrtSigmaRef, aSqrtSigmaRefErr, 6),
          refs: ["necco_sommer_2002"],
          agreementLevel: aSqrtSigmaAgreement.level,
          agreementText: aSqrtSigmaAgreement.text,
        });
      }
      if (hasAFm && Number.isFinite(r0Fm) && Number.isFinite(r0FmErr)) {
        potentialCompareRows.push({
          domain: "Potential",
          observable: "r0 from r0^2*F(r0)=1.65",
          measured: `${fmtPM(r0Fm, r0FmErr, 4)} fm`,
          target: `${fmtPM(r0RefFm, r0RefFmErr, 4)} fm`,
          refs: ["sommer_1994", "necco_sommer_2002"],
          agreementLevel: r0Agreement.level,
          agreementText: r0Agreement.text,
        });
      }
      if (hasAFm && Number.isFinite(r1Fm) && Number.isFinite(r1FmErr)) {
        potentialCompareRows.push({
          domain: "Potential",
          observable: "r1 from r1^2*F(r1)=1.00",
          measured: `${fmtPM(r1Fm, r1FmErr, 4)} fm`,
          target: `${fmtPM(r1RefFm, r1RefFmErr, 4)} fm`,
          refs: ["bazavov_2010"],
          agreementLevel: r1Agreement.level,
          agreementText: r1Agreement.text,
        });
      }
      lastPotentialCompareRows = potentialCompareRows;
      renderCombinedPhysicalComparison();
    }

    function drawSeries(canvasId, values, color, options = {}) {
      const bandLow = options.bandLow || null;
      const bandHigh = options.bandHigh || null;
      const bandColor = options.bandColor || "rgba(47, 208, 138, 0.18)";
      const includeZero = options.includeZero || false;
      const drawZeroLine = options.drawZeroLine || false;
      const xStartLabel = options.xStartLabel;
      const xEndLabel = options.xEndLabel;
      const c = document.getElementById(canvasId);
      const ctx = c.getContext("2d");
      const w = c.width, h = c.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#0d1526";
      ctx.fillRect(0, 0, w, h);

      if (!values || values.length < 2) {
        ctx.fillStyle = "#93a4be";
        ctx.font = "13px sans-serif";
        ctx.fillText("Not enough data yet", 18, 28);
        return;
      }

      const yvals = [...values];
      if (Array.isArray(bandLow)) yvals.push(...bandLow);
      if (Array.isArray(bandHigh)) yvals.push(...bandHigh);
      if (includeZero) yvals.push(0);
      let min = Math.min(...yvals);
      let max = Math.max(...yvals);
      if (min === max) { min -= 1e-9; max += 1e-9; }
      const pad = 28;
      const iw = w - 2 * pad;
      const ih = h - 2 * pad;

      ctx.strokeStyle = "#34435f";
      ctx.lineWidth = 1;
      ctx.strokeRect(pad, pad, iw, ih);

      if (drawZeroLine && min <= 0 && max >= 0) {
        const y0 = pad + (1 - (0 - min) / (max - min)) * ih;
        ctx.strokeStyle = "rgba(255, 208, 120, 0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pad, y0);
        ctx.lineTo(pad + iw, y0);
        ctx.stroke();
        ctx.fillStyle = "rgba(255, 208, 120, 0.95)";
        ctx.font = "11px sans-serif";
        ctx.fillText("0", pad + 4, y0 - 4);
      }

      if (Array.isArray(bandLow) && Array.isArray(bandHigh) && bandLow.length === values.length && bandHigh.length === values.length) {
        ctx.fillStyle = bandColor;
        ctx.beginPath();
        for (let i = 0; i < values.length; i += 1) {
          const x = pad + (i / Math.max(1, values.length - 1)) * iw;
          const y = pad + (1 - (bandHigh[i] - min) / (max - min)) * ih;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        for (let i = values.length - 1; i >= 0; i -= 1) {
          const x = pad + (i / Math.max(1, values.length - 1)) * iw;
          const y = pad + (1 - (bandLow[i] - min) / (max - min)) * ih;
          ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
      }

      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      values.forEach((v, i) => {
        const x = pad + (i / (values.length - 1)) * iw;
        const y = pad + (1 - (v - min) / (max - min)) * ih;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();

      ctx.fillStyle = "#9fb0cc";
      ctx.font = "12px sans-serif";
      ctx.fillText(min.toExponential(3), 6, h - 8);
      ctx.fillText(max.toExponential(3), 6, 18);
      const x0Txt = String(xStartLabel ?? 0);
      const x1Txt = String(xEndLabel ?? Math.max(0, values.length - 1));
      ctx.fillText(x0Txt, pad, h - 8);
      const x1Width = ctx.measureText(x1Txt).width;
      ctx.fillText(x1Txt, Math.max(pad + 6, pad + iw - x1Width), h - 8);
    }

    function updateNextJobs() {
      const p = currentProgress;
      const meta = currentMeta;
      const out = [];
      if (!p || !meta || !Array.isArray(meta.L)) {
        document.getElementById("nextJobsList").textContent = "Waiting for run metadata...";
        return;
      }

      const L = meta.L.map(x => Number(x));
      const Lbump = L.map((x, i) => (i < 3 ? Math.floor(x * 1.5) : x));
      const Ldouble = L.map((x, i) => (i < 3 ? x * 2 : x));
      const beta = Number(meta.beta || 0);
      const ntherm = toFiniteNumber(p.ntherm, NaN);
      const nmeas = toFiniteNumber(p.nmeas, NaN);
      const nthermTxt = Number.isFinite(ntherm) ? String(ntherm) : "-";
      const nmeasTxt = Number.isFinite(nmeas) ? String(nmeas) : "-";
      const betaVals = [beta - 0.1, beta, beta + 0.1]
        .map(x => Math.round(x * 100) / 100)
        .filter(x => x > 0);

      out.push(`1) Larger volume check: L=${fmtList(Lbump)}, beta=${beta.toFixed(2)}, ntherm=${nthermTxt}, nmeas=${nmeasTxt}`);
      out.push(`2) Large-volume stretch: L=${fmtList(Ldouble)}, beta=${beta.toFixed(2)}, ntherm=${Number.isFinite(ntherm) ? Math.max(300, ntherm) : 300}, nmeas=${Number.isFinite(nmeas) ? Math.max(300, nmeas) : 300}`);
      out.push(`3) Beta scan at current L=${fmtList(L)}: beta in {${betaVals.join(", ")}}`);
      out.push(`4) Combined step: L=${fmtList(Lbump)} with beta=${(beta + 0.1).toFixed(2)} for finer spacing test`);
      document.getElementById("nextJobsList").innerHTML = out.map(x => `<div>${x}</div>`).join("");
    }

    function renderThermalizationTrace(p, elapsedSec) {
      const countEl = document.getElementById("thermSweepCount");
      const metaEl = document.getElementById("thermSweepMeta");
      const hintEl = document.getElementById("thermSweepHint");
      const stepPctEl = document.getElementById("thermStepPct");
      if (!countEl || !metaEl || !hintEl) return;

      const sweepsDone = toFiniteNumber(p.sweeps_done, NaN);
      const totalSweeps = toFiniteNumber(p.total_sweeps, NaN);
      const therm = estimateThermState(p, elapsedSec);
      const phase = therm.phase;
      const ntherm = therm.ntherm;
      const thermDone = therm.thermDone;
      const thermLive = therm.thermLive;
      const inSweepFrac = therm.inSweepFrac;
      const elapsedVal = therm.elapsedVal;

      let frac = 0.0;
      if (Number.isFinite(ntherm) && ntherm > 0 && Number.isFinite(thermLive)) {
        frac = clamp01(thermLive / ntherm);
      } else if (Number.isFinite(totalSweeps) && totalSweeps > 0 && Number.isFinite(sweepsDone)) {
        frac = clamp01(sweepsDone / totalSweeps);
      }

      const cold = [82, 173, 255];
      const hot = [255, 122, 64];
      const rgb = mixRgb(cold, hot, frac);
      countEl.style.color = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;

      if (Number.isFinite(ntherm) && ntherm > 0 && Number.isFinite(thermLive)) {
        countEl.textContent = `${Math.round(thermDone)} / ${Math.round(ntherm)} sweeps`;
        metaEl.textContent = `phase=${phase}, thermalization ${(100 * frac).toFixed(1)}%`;
      } else if (Number.isFinite(sweepsDone) && sweepsDone >= 0) {
        countEl.textContent = Number.isFinite(totalSweeps) && totalSweeps > 0
          ? `${Math.round(sweepsDone)} / ${Math.round(totalSweeps)} sweeps`
          : `${Math.round(sweepsDone)} sweeps`;
        metaEl.textContent = `phase=${phase}`;
      } else {
        countEl.textContent = "- / - sweeps";
        metaEl.textContent = "waiting for thermalization counters";
      }

      if (stepPctEl) {
        if (phase === "thermalization" && Number.isFinite(inSweepFrac)) {
          stepPctEl.textContent = `${Math.round(100 * inSweepFrac)}%`;
          setPct("thermStepFill", 100 * inSweepFrac);
        } else if (phase !== "thermalization" && Number.isFinite(ntherm) && Number.isFinite(thermDone) && thermDone >= ntherm) {
          stepPctEl.textContent = "done";
          setPct("thermStepFill", 100);
        } else {
          stepPctEl.textContent = "-";
          setPct("thermStepFill", 0);
        }
      }

      const elapsedTxt = Number.isFinite(elapsedVal) ? fmtSec(elapsedVal) : "-";
      hintEl.textContent = `color: cold->hot by overall thermalization progress, elapsed=${elapsedTxt}`;
    }

    function renderProgress(p, source = "unknown") {
      if (!p) return;
      if (!shouldApplyProgressUpdate(p, source)) return;
      currentProgress = p;
      if (p?.seed) {
        threadProgressBySeed[String(p.seed)] = p;
      }
      const seed = progressSeed(p);
      const tsMs = Date.parse(p.timestamp_utc || "");
      const phase = String(p.phase || "").toLowerCase();
      const terminalPhase = terminalPhaseSet.has(phase);
      const liveElapsedFromProgress = () => {
        const elapsedLive = toFiniteNumber(p.elapsed_sec_live, NaN);
        if (Number.isFinite(elapsedLive)) return elapsedLive;
        const elapsedBase = toFiniteNumber(p.elapsed_sec, NaN);
        if (!Number.isFinite(elapsedBase)) return NaN;
        if (p.done || terminalPhase || !Number.isFinite(tsMs)) return elapsedBase;
        return elapsedBase + Math.max(0, (Date.now() - tsMs) / 1000.0);
      };
      document.getElementById("phaseBadge").textContent = `phase: ${p.phase}${p.done ? " (done)" : ""}`;
      document.getElementById("lastUpdate").textContent = `Last update: ${new Date().toLocaleTimeString()}`;
      document.getElementById("overallPct").textContent = `${(100 * p.progress).toFixed(1)}%`;
      document.getElementById("paramSeed").textContent = p.seed || "-";
      document.getElementById("paramCompute").textContent = formatComputeSummary(
        resolveComputeSummary(p, currentMeta),
        { short: false }
      );
      setPct("overallFill", 100 * p.progress);

      const hasCfgProgress = Number.isFinite(toFiniteNumber(p.cfg_total, NaN)) && toFiniteNumber(p.cfg_total, 0) > 0;
      const overallLabel = document.getElementById("overallLabel");
      if (overallLabel) {
        overallLabel.textContent = hasCfgProgress ? "Overall config progress" : "Overall sweep progress";
      }
      if (hasCfgProgress) {
        const cfgDone = toFiniteNumber(p.cfg_done, 0);
        const cfgTotal = toFiniteNumber(p.cfg_total, 0);
        const ntherm = toFiniteNumber(p.ntherm, NaN);
        const thermDone = toFiniteNumber(p.therm_done, NaN);
        const nmeas = toFiniteNumber(p.nmeas, NaN);
        const measDone = toFiniteNumber(p.meas_done, NaN);
        const hasTherm = Number.isFinite(ntherm) && Number.isFinite(thermDone) && ntherm > 0;
        const hasMeas = Number.isFinite(nmeas) && Number.isFinite(measDone) && nmeas > 0;

        // Do not map thermalization counters to cfg progress; keep those separate.
        const thermLive = hasTherm
          ? Math.min(
              ntherm,
              thermDone + (
                phase === "thermalization" &&
                !p.done &&
                thermDone > 0 &&
                thermDone < ntherm &&
                Number.isFinite(tsMs)
                  ? Math.min(
                      0.999,
                      Math.max(0, (Date.now() - tsMs) / 1000.0) /
                        Math.max(1e-9, liveElapsedFromProgress() / thermDone)
                    )
                  : 0
              )
            )
          : NaN;
        const thermOverallPct = hasTherm ? (100 * thermLive / ntherm) : NaN;
        document.getElementById("thermPct").textContent = hasTherm ? `${thermOverallPct.toFixed(1)}%` : "-";
        document.getElementById("measPct").textContent = hasMeas ? `${measDone} / ${nmeas}` : "- / -";
        document.getElementById("cfgDoneMeasured").textContent = `${cfgDone} / ${cfgTotal}`;
        document.getElementById("paramTherm").textContent = hasTherm ? `${Math.round(thermDone)}/${Math.round(ntherm)} completed` : "-";
        document.getElementById("paramMeas").textContent = hasMeas ? `${measDone}/${nmeas}` : `${cfgDone}/${cfgTotal}`;
        renderMeasurementCounter(p, hasMeas ? measDone : NaN, hasMeas ? nmeas : NaN);
        setPct("thermFill", hasTherm ? thermOverallPct : 0);
        setPct("measFill", hasMeas ? (100 * measDone / nmeas) : 0);

        let elapsedSec = liveElapsedFromProgress();
        let etaSec = toFiniteNumber(p.eta_sec, NaN);
        if (!Number.isFinite(elapsedSec) && Number.isFinite(tsMs)) {
          if (!progressStateBySeed[seed]) {
            progressStateBySeed[seed] = { startTsMs: tsMs, startDone: cfgDone };
          }
          const st = progressStateBySeed[seed];
          elapsedSec = Math.max(0, (tsMs - st.startTsMs) / 1000.0);
          const deltaDone = Math.max(0, cfgDone - st.startDone);
          if (!Number.isFinite(etaSec) && deltaDone > 0 && cfgTotal > cfgDone && elapsedSec > 0) {
            const rate = deltaDone / elapsedSec;
            if (rate > 0) etaSec = (cfgTotal - cfgDone) / rate;
          }
        }
        document.getElementById("elapsedVal").textContent = fmtSec(elapsedSec);
        document.getElementById("etaVal").textContent = p.done ? "done" : fmtSec(etaSec);
      } else {
        const therm = estimateThermState(p, liveElapsedFromProgress());
        const thermOverallPct =
          Number.isFinite(therm.ntherm) && therm.ntherm > 0 && Number.isFinite(therm.thermLive)
            ? 100 * therm.thermLive / therm.ntherm
            : NaN;
        const measDoneSingle = toFiniteNumber(p.meas_done, NaN);
        const nmeasSingle = toFiniteNumber(p.nmeas, NaN);
        const measAgg = aggregateThreadMeasurementCounters(p);
        const measDone = measAgg ? measAgg.done : measDoneSingle;
        const nmeas = measAgg ? measAgg.total : nmeasSingle;
        const measCfgIdx = toFiniteNumber(p.meas_cfg_index, NaN);
        const measSubDone = toFiniteNumber(p.meas_cfg_substep_done, NaN);
        const measSubTotal = toFiniteNumber(p.meas_cfg_substep_total, NaN);
        const measSubProgressRaw = toFiniteNumber(p.meas_cfg_substep_progress, NaN);
        let measSubProgress = Number.isFinite(measSubProgressRaw)
          ? Math.min(1, Math.max(0, measSubProgressRaw))
          : NaN;
        if (!Number.isFinite(measSubProgress) && Number.isFinite(measSubDone) && Number.isFinite(measSubTotal) && measSubTotal > 0) {
          measSubProgress = Math.min(1, Math.max(0, measSubDone / measSubTotal));
        }
        const hasMeasProgress = Number.isFinite(measDone) && Number.isFinite(nmeas) && nmeas > 0;
        const showMeasSub =
          !measAgg &&
          hasMeasProgress &&
          phase === "production" &&
          !p.done &&
          Number.isFinite(measCfgIdx) &&
          measCfgIdx >= 1 &&
          measCfgIdx <= nmeas &&
          Number.isFinite(measSubProgress);

        document.getElementById("thermPct").textContent = Number.isFinite(thermOverallPct) ? `${thermOverallPct.toFixed(1)}%` : "-";
        if (showMeasSub) {
          document.getElementById("measPct").textContent = `${Math.round(measDone)} / ${Math.round(nmeas)}`;
        } else if (hasMeasProgress) {
          document.getElementById("measPct").textContent = `${Math.round(measDone)} / ${Math.round(nmeas)}`;
        } else {
          document.getElementById("measPct").textContent = `${p.meas_done} / ${p.nmeas}`;
        }
        document.getElementById("cfgDoneMeasured").textContent = hasMeasProgress
          ? `${Math.round(measDone)} / ${Math.round(nmeas)}`
          : `${p.meas_done} / ${p.nmeas}`;
        document.getElementById("paramTherm").textContent =
          Number.isFinite(therm.ntherm) && therm.ntherm > 0 && Number.isFinite(therm.thermDone)
            ? `${Math.round(therm.thermDone)}/${Math.round(therm.ntherm)} completed`
            : "-";
        document.getElementById("paramMeas").textContent = hasMeasProgress
          ? `${Math.round(measDone)}/${Math.round(nmeas)}`
          : `${p.meas_done}/${p.nmeas}`;
        renderMeasurementCounter(p, hasMeasProgress ? measDone : NaN, hasMeasProgress ? nmeas : NaN);
        setPct("thermFill", Number.isFinite(thermOverallPct) ? thermOverallPct : 0);
        const measFillPct = hasMeasProgress
          ? 100 * (Math.min(nmeas, measDone + (showMeasSub ? measSubProgress : 0)) / nmeas)
          : (p.nmeas > 0 ? 100 * p.meas_done / p.nmeas : 0);
        setPct("measFill", measFillPct);
        document.getElementById("elapsedVal").textContent = fmtSec(liveElapsedFromProgress());
        document.getElementById("etaVal").textContent = p.done ? "done" : fmtSec(p.eta_sec);
      }

      const plaq = toFiniteNumber(p.last_plaquette, NaN);
      document.getElementById("plaqVal").textContent = Number.isFinite(plaq) ? plaq.toFixed(8) : "-";
      renderCurrentConfigProgress(p, phase);
      renderThreadCursors(p);
      renderThermalizationTrace(p, liveElapsedFromProgress());
      updatePhysicalScale(currentMeta);
      updateNextJobs();
      refreshThreadStatusTable(false);
    }

    function renderLive(live, livePathHint = null) {
      const livePath = normalizePath(livePathHint || document.getElementById("livePath")?.value || "");
      live = applyCachedMeasurements(livePath, live);
      currentMeta = live && live.meta ? live.meta : null;
      if (currentMeta) {
        document.getElementById("paramL").textContent = fmtList(currentMeta.L);
        document.getElementById("paramBeta").textContent = currentMeta.beta ?? "-";
        document.getElementById("paramR").textContent = fmtList(currentMeta.R);
        document.getElementById("paramT").textContent = fmtList(currentMeta.T);
        document.getElementById("paramFlux").textContent =
          `R=${currentMeta.flux_r}, T=${currentMeta.flux_t}, r_perp<=${currentMeta.flux_r_perp_max}`;
        const smode = currentMeta.sampling_mode || "full";
        const ssites = Number(currentMeta.sample_sites || 0);
        document.getElementById("paramSampling").textContent =
          smode === "random" ? `random (${ssites} sites/obs)` : "full-volume";
        document.getElementById("paramCompute").textContent = formatComputeSummary(
          resolveComputeSummary(currentProgress, currentMeta),
          { short: false }
        );
        updatePhysicalScale(currentMeta);
      }
      if (currentProgress) {
        renderThreadCursors(currentProgress);
      }
      const ms = (live && live.measurements) || [];
      cacheLiveMeasurements(resolveLiveSeed(live, livePath), ms);
      currentMeasurements = ms;
      const last = ms.length > 0 ? ms[ms.length - 1] : null;
      const dataSig = `${ms.length}:${last?.idx ?? -1}:${last?.cfg_idx ?? -1}:${last?.plaquette ?? "na"}:${currentMeta?.timestamp_utc ?? ""}`;
      const renderSig = `${dataSig}:${document.getElementById("fluxDisplayMode").value}:${document.getElementById("fluxTailN").value}:${isLegacyFilterEnabled() ? 1 : 0}:${loopKey || ""}`;
      if (renderSig === lastRenderSignature) return;
      lastRenderSignature = renderSig;

      document.getElementById("historyCount").textContent = `${ms.length} points (mean ± SEM)`;
      const plaq = ms.map(x => x.plaquette);
      const plaqStats = runningMeanSem(plaq);
      drawSeries("plaqCanvas", plaqStats.mean, "#2fd08a", {
        bandLow: plaqStats.low,
        bandHigh: plaqStats.high,
        bandColor: "rgba(47, 208, 138, 0.22)",
        includeZero: true,
        drawZeroLine: true,
        xStartLabel: 1,
        xEndLabel: plaqStats.mean.length
      });
      const plaqVals = plaq.map((x) => toFiniteNumber(x, NaN)).filter(Number.isFinite);
      if (plaqVals.length < 8) {
        setSignalNote("plaqSignal", "na", `Need more plaquette history for convergence check (N=${plaqVals.length}).`);
      } else {
        const w = Math.max(4, Math.min(20, Math.floor(plaqVals.length / 2)));
        const recent = plaqVals.slice(-w);
        const prev = plaqVals.length >= 2 * w ? plaqVals.slice(-2 * w, -w) : plaqVals.slice(0, w);
        const sRecent = meanSem(recent);
        const sPrev = meanSem(prev);
        const drift = Math.abs((sRecent?.mean ?? NaN) - (sPrev?.mean ?? NaN));
        const driftSem = Math.sqrt(
          Math.pow(Math.max(1e-12, Number(sRecent?.sem) || 0), 2) +
          Math.pow(Math.max(1e-12, Number(sPrev?.sem) || 0), 2)
        );
        let plaqLevel = "red";
        let plaqText = `Plaquette still drifting: ${fmtPM(sRecent?.mean, sRecent?.sem, 7)}, window drift=${Number.isFinite(drift) ? drift.toExponential(2) : "-"}.`;
        if (Number.isFinite(drift) && drift <= 1.5 * driftSem) {
          plaqLevel = "green";
          plaqText = `Plaquette running mean stable: ${fmtPM(sRecent?.mean, sRecent?.sem, 7)}, drift=${drift.toExponential(2)}.`;
        } else if (Number.isFinite(drift) && drift <= 3.0 * driftSem) {
          plaqLevel = "yellow";
          plaqText = `Plaquette nearly stable: ${fmtPM(sRecent?.mean, sRecent?.sem, 7)}, drift=${drift.toExponential(2)}.`;
        }
        setSignalNote("plaqSignal", plaqLevel, plaqText);
      }

      if (!loopKey && live && live.meta && live.meta.flux_r && live.meta.flux_t) {
        loopKey = `R${live.meta.flux_r}_T${live.meta.flux_t}`;
      }
      if (!loopKey && ms.length > 0) {
        const keys = Object.keys(ms[0].loops || {});
        loopKey = keys.length > 0 ? keys[0] : null;
      }
      document.getElementById("loopKeyLabel").textContent = `key: ${loopKey || "-"}`;
      document.getElementById("loopAxes").textContent =
        `x: measurement index, y: running mean of Re ${loopKey || "W(R,T)"}`;
      const loopVals = loopKey ? ms.map(x => (x.loops?.[loopKey]?.re ?? 0)) : [];
      const loopStats = runningMeanSem(loopVals);
      drawSeries("loopCanvas", loopStats.mean, "#52adff", {
        bandLow: loopStats.low,
        bandHigh: loopStats.high,
        bandColor: "rgba(82, 173, 255, 0.22)",
        includeZero: true,
        drawZeroLine: true,
        xStartLabel: 1,
        xEndLabel: loopStats.mean.length
      });
      const loopValsFinite = loopVals.map((x) => toFiniteNumber(x, NaN)).filter(Number.isFinite);
      if (!loopKey || loopValsFinite.length < 8) {
        setSignalNote("loopSignal", "na", `Need more loop samples for ${loopKey || "selected key"} (N=${loopValsFinite.length}).`);
      } else {
        const st = meanSem(loopValsFinite);
        const snr = st && st.sem > 0 ? Math.abs(st.mean) / st.sem : NaN;
        const w = Math.max(4, Math.min(20, Math.floor(loopValsFinite.length / 2)));
        const recent = loopValsFinite.slice(-w);
        const prev = loopValsFinite.length >= 2 * w ? loopValsFinite.slice(-2 * w, -w) : loopValsFinite.slice(0, w);
        const sRecent = meanSem(recent);
        const sPrev = meanSem(prev);
        const drift = Math.abs((sRecent?.mean ?? NaN) - (sPrev?.mean ?? NaN));
        const driftSem = Math.sqrt(
          Math.pow(Math.max(1e-12, Number(sRecent?.sem) || 0), 2) +
          Math.pow(Math.max(1e-12, Number(sPrev?.sem) || 0), 2)
        );
        let loopLevel = "red";
        let loopText = `${loopKey}: weak signal, <ReW>=${fmtPM(st?.mean, st?.sem, 6)}, SNR=${Number.isFinite(snr) ? snr.toFixed(2) : "-"}.`;
        if (Number.isFinite(snr) && snr >= 3.0 && Number.isFinite(drift) && drift <= 2.5 * driftSem) {
          loopLevel = "green";
          loopText = `${loopKey}: clear signal, <ReW>=${fmtPM(st?.mean, st?.sem, 6)}, SNR=${snr.toFixed(2)}.`;
        } else if (Number.isFinite(snr) && snr >= 1.5) {
          loopLevel = "yellow";
          loopText = `${loopKey}: signal emerging, <ReW>=${fmtPM(st?.mean, st?.sem, 6)}, SNR=${snr.toFixed(2)}.`;
        }
        setSignalNote("loopSignal", loopLevel, loopText);
      }

      const fluxView = buildFluxDisplaySeries(ms, currentMeta);
      const fluxStats = pointwiseMeanSem(fluxView.series);
      drawSeries("fluxCanvas", fluxStats.mean, "#f2c14b", {
        bandLow: fluxStats.low,
        bandHigh: fluxStats.high,
        bandColor: "rgba(242, 193, 75, 0.26)",
        includeZero: true,
        drawZeroLine: true,
        xStartLabel: 0,
        xEndLabel: Math.max(0, fluxStats.mean.length - 1)
      });
      const vacMode = fluxView.mode === "tail_subtracted" ? "tail_subtracted" : (fluxView.mode === "raw" ? "raw" : "stored");
      const vacTail = fluxView.mode === "tail_subtracted" ? String(fluxView.tailN) : "-";
      document.getElementById("fluxAxes").textContent =
        `x: r⊥ (lattice units), y: connected flux ΔP(r⊥), vacuum mode=${vacMode} (tail=${vacTail})`;
      document.getElementById("fluxModeNote").textContent = fluxView.note;
      document.getElementById("fluxLabel").textContent = `N=${ms.length} configs, connected flux mean ± SEM`;
      const fluxMean = fluxStats.mean.map((x) => toFiniteNumber(x, NaN));
      const fluxLow = fluxStats.low.map((x) => toFiniteNumber(x, NaN));
      const fluxHigh = fluxStats.high.map((x) => toFiniteNumber(x, NaN));
      const fluxFiniteIdx = fluxMean.map((v, i) => (Number.isFinite(v) ? i : -1)).filter((i) => i >= 0);
      if (ms.length < 8 || fluxFiniteIdx.length < 2) {
        setSignalNote("fluxSignal", "na", `Need more flux profiles for tube-shape signal (N=${ms.length}).`);
      } else {
        const centerIdx = fluxFiniteIdx[0];
        const tailN = Math.max(1, Math.floor(fluxFiniteIdx.length / 4));
        const tailIdxs = fluxFiniteIdx.slice(-tailN);
        const center = fluxMean[centerIdx];
        const centerHi = Number.isFinite(fluxHigh[centerIdx]) ? fluxHigh[centerIdx] : center;
        const centerLo = Number.isFinite(fluxLow[centerIdx]) ? fluxLow[centerIdx] : center;
        const centerSem = 0.5 * Math.abs(centerHi - centerLo);
        let tailMean = 0.0;
        let tailSem2 = 0.0;
        for (const i of tailIdxs) {
          tailMean += fluxMean[i];
          const hi = Number.isFinite(fluxHigh[i]) ? fluxHigh[i] : fluxMean[i];
          const lo = Number.isFinite(fluxLow[i]) ? fluxLow[i] : fluxMean[i];
          const sem = 0.5 * Math.abs(hi - lo);
          tailSem2 += sem * sem;
        }
        tailMean /= Math.max(1, tailIdxs.length);
        const tailSem = Math.sqrt(tailSem2) / Math.max(1, tailIdxs.length);
        const amp = Math.abs(center - tailMean);
        const ampSem = Math.sqrt(Math.max(1e-18, centerSem * centerSem + tailSem * tailSem));
        const snr = amp / ampSem;
        let fluxLevel = "red";
        let fluxText = `Flux shape weak: center-tail Δ=${fmtPM(amp, ampSem, 6)} (SNR=${Number.isFinite(snr) ? snr.toFixed(2) : "-"})`;
        if (Number.isFinite(snr) && snr >= 3.0) {
          fluxLevel = "green";
          fluxText = `Flux-tube profile visible: center-tail Δ=${fmtPM(amp, ampSem, 6)} (SNR=${snr.toFixed(2)}).`;
        } else if (Number.isFinite(snr) && snr >= 1.5) {
          fluxLevel = "yellow";
          fluxText = `Flux profile emerging: center-tail Δ=${fmtPM(amp, ampSem, 6)} (SNR=${snr.toFixed(2)}).`;
        }
        setSignalNote("fluxSignal", fluxLevel, fluxText);
      }
      document.getElementById("measureWhat").textContent =
        `Plaquette, Wilson loop ${loopKey || "W(R,T)"} (real part), Polyakov loops, V(R), and connected flux profile ΔP(r⊥).`;
      renderAutocorr(ms);
      renderPolyakov(ms);
      renderFluxDiagnostics(ms, currentMeta);
      renderPotential(ms, currentMeta);
      updateNextJobs();
    }

    function isCombineEnabled() {
      const el = document.getElementById("combineSeeds");
      return el && el.checked;
    }

    function buildDataUrl(path) {
      const url = new URL(withApiBase(path), window.location.origin);
      url.searchParams.set("_t", String(Date.now()));
      const token = (document.getElementById("authToken").value || "").trim();
      if (token) url.searchParams.set("token", token);
      if (isCombineEnabled()) url.searchParams.set("combine", "1");
      return { url: url.toString(), token };
    }

    async function fetchJson(path) {
      const req = buildDataUrl(path);
      const r = await fetch(req.url, {
        headers: req.token ? { "X-Auth-Token": req.token } : {},
      });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.json();
    }

    async function fetchText(path) {
      const req = buildDataUrl(path);
      const r = await fetch(req.url, {
        headers: req.token ? { "X-Auth-Token": req.token } : {},
      });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.text();
    }

    async function fetchLiveWithFallback(livePath) {
      const normalizedLivePath = normalizePath(livePath);
      let live = await fetchJson(normalizedLivePath);
      live = applyCachedMeasurements(normalizedLivePath, live);
      const hasInline = Array.isArray(live?.measurements) && live.measurements.length > 0;
      if (hasInline) return live;

      let mergedRows = [];
      const jsonlPath = deriveJsonlPath(normalizedLivePath, live);
      if (!jsonlPath || jsonlPath === normalizedLivePath) return live;
      try {
        const text = await fetchText(jsonlPath);
        const rows = parseJsonlMeasurements(text);
        if (rows.length > 0) {
          mergedRows = rows;
        }
      } catch (_) {
        // Keep live payload without measurements if JSONL fallback is unavailable.
      }

      const checkpointPath = deriveCheckpointPath(normalizedLivePath, live);
      if (checkpointPath && checkpointPath !== normalizedLivePath) {
        try {
          const cp = await fetchJson(checkpointPath);
          const cpRows = Array.isArray(cp?.measurements) ? cp.measurements : [];
          if (cpRows.length > 0) {
            const byIdx = new Map();
            for (const row of cpRows) {
              const idx = Number(row?.idx);
              if (Number.isFinite(idx)) byIdx.set(idx, row);
            }
            for (const row of mergedRows) {
              const idx = Number(row?.idx);
              if (Number.isFinite(idx)) byIdx.set(idx, row);
            }
            const merged = [...byIdx.entries()]
              .sort((a, b) => a[0] - b[0])
              .map((x) => x[1]);
            if (merged.length > 0) {
              const out = { ...(live || {}), measurements: merged };
              cacheLiveMeasurements(resolveLiveSeed(out, normalizedLivePath), merged);
              return out;
            }
          }
        } catch (_) {
          // Ignore checkpoint fallback failures.
        }
      }

      if (mergedRows.length > 0) {
        const merged = { ...(live || {}), measurements: mergedRows };
        cacheLiveMeasurements(resolveLiveSeed(merged, normalizedLivePath), mergedRows);
        return merged;
      }
      return live;
    }

    async function refresh() {
      const progressPath = normalizePath(document.getElementById("progressPath").value);
      const livePath = normalizePath(document.getElementById("livePath").value);

      try {
        const p = await fetchJson(progressPath);
        renderProgress(p, "poll");
      } catch (e) {
        document.getElementById("phaseBadge").textContent = "phase: unavailable";
        document.getElementById("lastUpdate").textContent = `Progress read error: ${e.message}`;
        document.getElementById("cfgDoneMeasured").textContent = "- / -";
        const measCounterEl = document.getElementById("measCounterDetail");
        if (measCounterEl) measCounterEl.textContent = "N_meas = - / - (A=-, B=-, C=-, D=-)";
        document.getElementById("cfgSubPct").textContent = "-";
        for (const slot of threadSlots) {
          setPct(`cfgSubFill${slot.label}`, 0);
          const labelEl = document.getElementById(`cfgSubLabel${slot.label}`);
          if (labelEl) labelEl.textContent = `${slot.label} cfg- 0.0%`;
        }
      }

      try {
        const live = await fetchLiveWithFallback(livePath);
        renderLive(live, livePath);
      } catch (e) {
        document.getElementById("historyCount").textContent = `Live read error: ${e.message}`;
        drawSeries("plaqCanvas", [], "#2fd08a");
        drawSeries("loopCanvas", [], "#52adff");
        drawSeries("fluxCanvas", [], "#f2c14b");
        drawXYLine("tauCanvas", [], [], { color: "#52adff", emptyText: "Not enough plaquette points yet" });
        document.getElementById("tauLabel").textContent = "τ_int pending";
        document.getElementById("tauSummary").textContent = "Waiting for measurement history...";
        document.getElementById("polyLabel").textContent = "Re P_mu pending";
        document.getElementById("polySummary").textContent = "Waiting for Polyakov-loop telemetry...";
        const polyCanvas = document.getElementById("polyCanvas");
        if (polyCanvas) {
          const pctx = polyCanvas.getContext("2d");
          pctx.clearRect(0, 0, polyCanvas.width, polyCanvas.height);
          pctx.fillStyle = "#0d1526";
          pctx.fillRect(0, 0, polyCanvas.width, polyCanvas.height);
          pctx.fillStyle = "#93a4be";
          pctx.font = "13px sans-serif";
          pctx.fillText("No Polyakov-loop data yet", 18, 28);
        }
        drawXYError("vCanvas", [], [], []);
        document.getElementById("vLabel").textContent = "V(R) unavailable";
        document.getElementById("vTable").textContent = "No valid V(R) points yet.";
        document.getElementById("vForceTable").textContent = "Force diagnostics unavailable.";
        setSignalNote("plaqSignal", "na", `Live data unavailable: ${e.message}`);
        setSignalNote("loopSignal", "na", `Live data unavailable: ${e.message}`);
        setSignalNote("fluxSignal", "na", `Live data unavailable: ${e.message}`);
        setSignalNote("vSignal", "na", `Live data unavailable: ${e.message}`);
        setSignalNote("tauSignal", "na", `Live data unavailable: ${e.message}`);
        setSignalNote("polySignal", "na", `Live data unavailable: ${e.message}`);
        setVFitRows([], "Cornell fit unavailable.");
        setFluxDiagRows([], "Flux diagnostics unavailable.");
        lastPotentialCompareRows = [];
        lastFluxCompareRows = [];
        renderCombinedPhysicalComparison();
        currentMeasurements = [];
      }
      refreshThreadStatusTable(true);
    }

    function stopStream() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      usingStream = false;
    }

    function startStream() {
      if (!window.EventSource) {
        usingStream = false;
        setStreamStatus("stream: unsupported (polling)");
        return;
      }

      const progressPath = normalizePath(document.getElementById("progressPath").value);
      const livePath = normalizePath(document.getElementById("livePath").value);
      const token = (document.getElementById("authToken").value || "").trim();
      const streamUrl = new URL(withApiBase("/events"), window.location.origin);
      streamUrl.searchParams.set("progress", progressPath);
      streamUrl.searchParams.set("live", livePath);
      if (token) streamUrl.searchParams.set("token", token);
      if (isCombineEnabled()) streamUrl.searchParams.set("combine", "1");

      stopStream();
      setStreamStatus("stream: connecting...");
      eventSource = new EventSource(streamUrl.toString());

      eventSource.onopen = () => {
        usingStream = true;
        setStreamStatus("stream: connected");
      };

      eventSource.onmessage = (ev) => {
        if (paused) return;
        try {
          const payload = JSON.parse(ev.data);
          lastStreamAt = Date.now();
          if (payload.thread_progress && typeof payload.thread_progress === "object") {
            for (const [seed, tp] of Object.entries(payload.thread_progress)) {
              if (!tp || typeof tp !== "object") continue;
              if (shouldAcceptThreadProgress(seed, tp)) {
                threadProgressBySeed[seed] = tp;
              }
            }
          }
          if (payload.thread_telemetry && typeof payload.thread_telemetry === "object") {
            applyThreadTelemetryMap(payload.thread_telemetry);
          }
          if (payload.progress) renderProgress(payload.progress, "stream");
          if (payload.live) renderLive(payload.live, livePath);
          refreshThreadStatusTable(false);
          if (payload.errors && payload.errors.progress) {
            document.getElementById("lastUpdate").textContent = `Progress read error: ${payload.errors.progress}`;
          }
          if (payload.errors && payload.errors.live) {
            document.getElementById("historyCount").textContent = `Live read error: ${payload.errors.live}`;
          }
        } catch (_) {
          // Ignore malformed stream payload and keep running.
        }
      };

      eventSource.onerror = () => {
        usingStream = false;
        setStreamStatus("stream: reconnecting...");
      };
    }

    document.getElementById("reloadBtn").addEventListener("click", async () => {
      await refresh();
      if (!paused) startStream();
    });

    document.getElementById("toggleBtn").addEventListener("click", () => {
      paused = !paused;
      document.getElementById("toggleBtn").textContent = paused ? "Resume" : "Pause";
      if (paused) {
        stopStream();
        setStreamStatus("stream: paused");
      } else {
        refresh();
        startStream();
      }
    });

    document.getElementById("chatSendBtn").addEventListener("click", () => {
      sendChat();
    });
    document.getElementById("chatInput").addEventListener("keydown", (ev) => {
      if (ev.key === "Enter" && !ev.shiftKey) {
        ev.preventDefault();
        sendChat();
      }
    });
    document.getElementById("authToken").addEventListener("change", () => {
      if (!paused) startStream();
    });
    document.getElementById("apiBase").addEventListener("change", () => {
      if (!paused) {
        refresh();
        startStream();
      }
    });
    const rerenderPhysicalDerived = () => {
      updatePhysicalScale(currentMeta);
      if (Array.isArray(currentMeasurements) && currentMeasurements.length > 0) {
        renderPotential(currentMeasurements, currentMeta);
      }
    };
    document.getElementById("aFmInput").addEventListener("change", rerenderPhysicalDerived);
    document.getElementById("aFmInput").addEventListener("input", rerenderPhysicalDerived);
    document.getElementById("fluxDisplayMode").addEventListener("change", () => {
      refresh();
    });
    document.getElementById("fluxTailN").addEventListener("change", () => {
      refresh();
    });
    document.getElementById("legacyFilter").addEventListener("change", () => {
      refresh();
    });
    document.getElementById("combineSeeds").addEventListener("change", () => {
      refresh();
      if (!paused) startStream();
    });
    document.getElementById("threadVizMode").addEventListener("change", () => {
      applyThreadVizMode();
      renderThreadCursors(currentProgress);
    });
    for (const slot of threadSlots) {
      const suffix = String(slot?.label || "").toUpperCase();
      const seedForSlot = () => {
        const base = resolveThreadBaseSeed();
        return `${base}${slot.suffix}`;
      };
      const pauseBtn = document.getElementById(`threadPause${suffix}`);
      const resumeBtn = document.getElementById(`threadResume${suffix}`);
      const restartBtn = document.getElementById(`threadRestart${suffix}`);
      if (pauseBtn) {
        pauseBtn.addEventListener("click", async () => {
          const seed = pauseBtn.dataset.seed || seedForSlot();
          await runThreadControl("pause", { seed }, "thread");
        });
      }
      if (resumeBtn) {
        resumeBtn.addEventListener("click", async () => {
          const seed = resumeBtn.dataset.seed || seedForSlot();
          await runThreadControl("resume", { seed }, "thread");
        });
      }
      if (restartBtn) {
        restartBtn.addEventListener("click", async () => {
          const seed = restartBtn.dataset.seed || seedForSlot();
          await runThreadControl("restart", { seed }, "thread");
        });
      }
    }
    const pauseAllBtn = document.getElementById("threadPauseAllBtn");
    const resumeAllBtn = document.getElementById("threadResumeAllBtn");
    const restartAllBtn = document.getElementById("threadRestartAllBtn");
    if (pauseAllBtn) {
      pauseAllBtn.addEventListener("click", async () => {
        await runThreadControl("pause_all", { base_seed: resolveThreadBaseSeed() }, "threads");
      });
    }
    if (resumeAllBtn) {
      resumeAllBtn.addEventListener("click", async () => {
        await runThreadControl("resume_all", { base_seed: resolveThreadBaseSeed() }, "threads");
      });
    }
    if (restartAllBtn) {
      restartAllBtn.addEventListener("click", async () => {
        await runThreadControl("restart_all", { base_seed: resolveThreadBaseSeed() }, "threads");
      });
    }

    applyUrlDefaults();
    applyThreadVizMode();
    addChat("system", "Admin chat ready.");
    refresh();
    startStream();
    setInterval(() => {
      if (paused) return;
      if (!currentProgress) return;
      const phase = String(currentProgress?.phase || "").toLowerCase();
      renderCurrentConfigProgress(currentProgress, phase);
      renderThreadCursors(currentProgress);
    }, 1000);
    setInterval(() => {
      if (paused) return;
      if (!usingStream || Date.now() - lastStreamAt > streamStaleMs) {
        refresh();
      }
    }, pollMs);
  </script>
</body>
</html>
